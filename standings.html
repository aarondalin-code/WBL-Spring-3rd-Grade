<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings • WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl2026" />
</head>

<body class="watermarkPage standingsPage hasHamburger">
<header class="siteHeader">
  <div class="navWrap">
    <button
      class="navToggle"
      type="button"
      aria-label="Open menu"
      aria-expanded="false"
      aria-controls="siteNav"
    >
      <span></span><span></span><span></span>
    </button>

    <div class="navOverlay" aria-hidden="true"></div>

    <nav class="nav" id="siteNav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html" class="active">Standings</a>
      <a href="./teams.html">Teams</a>
      <a href="./playoffs.html">Playoffs</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>
  </div>

  <div class="brandCenter">
    <img src="./logo.png" alt="WBL Logo" class="logoImage" />
    <h1>WBL 3rd Grade 2026</h1>
    <div class="tagline">Standings</div>
  </div>
</header>

<main class="wrap">
  <section class="docSection">

    <div class="standingsHeaderCard">
      <div class="standingsHeaderTitle">Standings</div>
      <div class="standingsHeaderSub muted">
        Auto-calculated from games marked <strong>Final</strong> in the Google Sheet.
      </div>
      <div class="standingsHeaderMeta muted small" id="standingsUpdated"></div>
    </div>

    <div class="card">
      <div class="cardBody">
        <div class="tableScroll">
          <table id="standingsTable" class="standingsTable">
            <thead>
              <tr>
                <th>Team</th>
                <th class="num">Wins</th>
                <th class="num">Losses</th>
                <th class="num">Ties</th>
                <th class="num">Runs For</th>
                <th class="num">Runs Against</th>
                <th class="num">Run Diff</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <p id="standingsMsg" class="muted small" style="margin-top:12px;"></p>
      </div>
    </div>
  </section>
</main>

<script src="./data.js"></script>

<script>
  const tbody = document.querySelector("#standingsTable tbody");
  const msgEl = document.getElementById("standingsMsg");
  const updatedEl = document.getElementById("standingsUpdated");

  function safe(v){ return String(v ?? "").trim(); }

  // Accept "Final" or "Final ..." variants
  function isFinal(status){
    const s = safe(status).toLowerCase();
    return s === "final" || s.startsWith("final");
  }

  function toNum(x){
    const n = Number(safe(x));
    return Number.isFinite(n) ? n : null;
  }

  function normalizeKey(s){ return safe(s).toLowerCase(); }

  function slugifyTeamName(name) {
    return safe(name)
      .toLowerCase()
      .replace(/&/g, "and")
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  async function fetchCsv(url) {
    if (!url) throw new Error("Missing CSV URL in data.js");
    const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(url + bust, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
    return await res.text();
  }

  // Robust CSV parser (quoted commas safe) + BOM strip
  function parseCsv(text) {
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (ch === '"') {
        if (inQuotes && next === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
        continue;
      }

      if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

      if (!inQuotes && (ch === "\n" || ch === "\r")) {
        if (ch === "\r" && next === "\n") i++;
        row.push(cur); cur = "";
        if (row.some(v => safe(v) !== "")) rows.push(row);
        row = [];
        continue;
      }

      cur += ch;
    }

    row.push(cur);
    if (row.some(v => safe(v) !== "")) rows.push(row);

    const headers = (rows.shift() || []).map((h) => {
      let key = safe(h).replace(/\s+/g, "");
      key = key.replace(/^\uFEFF/, ""); // strip BOM
      return key;
    });

    return rows
      .filter(r => r.some(x => safe(x) !== ""))
      .map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h] = safe(r[idx]));
        return obj;
      });
  }

  function buildStandings(teamNames){
    const map = new Map();
    for (const name of teamNames) {
      if (!name) continue;
      map.set(name, { team: name, W: 0, L: 0, T: 0, RF: 0, RA: 0, RD: 0 });
    }
    return map;
  }

  function sortStandings(a, b) {
    // W desc, L asc, RD desc, RF desc, team asc
    if (b.W !== a.W) return b.W - a.W;
    if (a.L !== b.L) return a.L - b.L;
    if (b.RD !== a.RD) return b.RD - a.RD;
    if (b.RF !== a.RF) return b.RF - a.RF;
    return a.team.localeCompare(b.team);
  }

  function renderRows(rows, teamNameToSlug){
    tbody.innerHTML = "";

    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      if (idx === 0) tr.classList.add("standingsTop1");
      if (idx === 1) tr.classList.add("standingsTop2");

      const slug = teamNameToSlug.get(normalizeKey(r.team)) || slugifyTeamName(r.team);

      const tdTeam = document.createElement("td");
      tdTeam.innerHTML = `<a class="teamLink" href="./team.html?team=${encodeURIComponent(slug)}">${r.team}</a>`;
      tr.appendChild(tdTeam);

      const cells = [
        { v: r.W, cls: "num" },
        { v: r.L, cls: "num" },
        { v: r.T, cls: "num" },
        { v: r.RF, cls: "num" },
        { v: r.RA, cls: "num" },
        { v: (r.RD > 0 ? "+" : "") + r.RD, cls: "num rd" }
      ];

      for (const c of cells) {
        const td = document.createElement("td");
        td.className = c.cls;
        td.textContent = c.v;
        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    });
  }

  async function init(){
    msgEl.textContent = "";
    updatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;

    // Load teams for (a) complete list and (b) name->slug link mapping
    const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
    const teamRows = parseCsv(teamsCsv);

    const teamNames = teamRows.map(r => safe(r.TeamName)).filter(Boolean);

    const teamNameToSlug = new Map();
    for (const r of teamRows) {
      const name = safe(r.TeamName);
      const slug = safe(r.TeamSlug);
      if (name && slug) teamNameToSlug.set(normalizeKey(name), slug);
    }

    const standings = buildStandings(teamNames);

    // Load games
    const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
    const gameRows = parseCsv(gamesCsv);

    // Count final games where TeamA/TeamB are plain team names
    const finalGames = gameRows.filter(g => isFinal(g.Status));
    let counted = 0;

    for (const g of finalGames) {
      const aName = safe(g.TeamA);
      const bName = safe(g.TeamB);
      const scoreA = toNum(g.ScoreA);
      const scoreB = toNum(g.ScoreB);

      if (!aName || !bName || scoreA === null || scoreB === null) continue;

      if (!standings.has(aName)) standings.set(aName, { team: aName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });
      if (!standings.has(bName)) standings.set(bName, { team: bName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });

      const A = standings.get(aName);
      const B = standings.get(bName);

      A.RF += scoreA; A.RA += scoreB;
      B.RF += scoreB; B.RA += scoreA;

      if (scoreA > scoreB) { A.W++; B.L++; }
      else if (scoreB > scoreA) { B.W++; A.L++; }
      else { A.T++; B.T++; }

      counted++;
    }

    for (const v of standings.values()) v.RD = v.RF - v.RA;

    const rows = Array.from(standings.values()).sort(sortStandings);
    renderRows(rows, teamNameToSlug);

    msgEl.textContent = counted
      ? `Standings based on ${counted} final game(s).`
      : `No final games yet — standings will populate once games are marked Final.`;
  }

  init().catch(err => {
    console.error(err);
    msgEl.textContent = "Standings error: " + err.message;
  });
</script>

<script src="./nav.js"></script>
</body>
</html>


