<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings • WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl2026-standings3" />
</head>

<body class="watermarkPage standingsPage hasHamburger">
<header class="siteHeader">
  <div class="navWrap">
    <button class="navToggle" type="button" aria-label="Open menu" aria-expanded="false" aria-controls="siteNav">
      <span></span><span></span><span></span>
    </button>

    <div class="navOverlay" aria-hidden="true"></div>

    <nav class="nav" id="siteNav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html" class="active">Standings</a>
      <a href="./teams.html">Teams</a>
      <a href="./playoffs.html">Playoffs</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>
  </div>

  <div class="brandCenter">
    <img src="./logo.png" alt="WBL Logo" class="logoImage" />
    <h1>WBL 3rd Grade 2026</h1>
    <div class="tagline">Standings</div>
  </div>
</header>

<main class="wrap">
  <section class="docSection">
    <div class="card">
      <div class="cardBody">

        <div class="standingsTopBar">
          <div>
            <div class="standingsTitle">Standings</div>
            <div class="muted small">
              Auto-calculated from games marked <strong>Final</strong>. Click a column header to sort.
            </div>
          </div>
          <div class="standingsMeta muted small" id="standingsUpdated"></div>
        </div>

        <div class="tableScroll standingsTableScroll">
          <table id="standingsTable" class="standingsTableModern">
            <thead>
              <tr>
                <th class="colTeam">Team</th>

                <th class="colNum sortTh" data-sort="W">W</th>
                <th class="colNum sortTh" data-sort="L">L</th>
                <th class="colNum sortTh" data-sort="T">T</th>

                <th class="colNum sortTh" data-sort="GP">GP</th>
                <th class="colNum sortTh" data-sort="PCT">Win%</th>

                <th class="colNum sortTh" data-sort="RF">RF</th>
                <th class="colNum sortTh" data-sort="RA">RA</th>
                <th class="colNum colRd sortTh" data-sort="RD">RD</th>

                <th class="colStreak sortTh" data-sort="STREAK">Streak</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <p id="standingsMsg" class="muted small" style="margin-top:12px;"></p>

      </div>
    </div>
  </section>
</main>

<script src="./data.js"></script>

<script>
  const tbody = document.querySelector("#standingsTable tbody");
  const msgEl = document.getElementById("standingsMsg");
  const updatedEl = document.getElementById("standingsUpdated");

  // Teams meta from Teams CSV:
  // key: normalized TeamName -> { slug, logo, color }
  const teamMeta = new Map();

  // Sort state
  let sortKey = "PCT";
  let sortDir = "desc"; // "asc" | "desc"

  function safe(v){ return String(v ?? "").trim(); }
  function norm(v){ return safe(v).toLowerCase(); }
  function isFinal(status){ return norm(status) === "final"; }

  function toNum(x){
    const n = Number(safe(x));
    return Number.isFinite(n) ? n : null;
  }

  async function fetchCsv(url) {
    if (!url) throw new Error("Missing CSV URL in data.js");
    const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(url + bust, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
    return await res.text();
  }

  // Robust CSV parser (quoted commas safe)
  function parseCsv(text) {
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (ch === '"') {
        if (inQuotes && next === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
        continue;
      }

      if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

      if (!inQuotes && (ch === "\n" || ch === "\r")) {
        if (ch === "\r" && next === "\n") i++;
        row.push(cur); cur = "";
        if (row.some(v => safe(v) !== "")) rows.push(row);
        row = [];
        continue;
      }

      cur += ch;
    }

    row.push(cur);
    if (row.some(v => safe(v) !== "")) rows.push(row);

    const headers = (rows.shift() || []).map(h => safe(h).replace(/\s+/g,""));
    return rows.map(r => {
      const obj = {};
      headers.forEach((h, idx) => obj[h] = safe(r[idx]));
      return obj;
    }).filter(o => Object.values(o).some(v => safe(v) !== ""));
  }

  function getMeta(teamName){
    const m = teamMeta.get(norm(teamName));
    return m || {
      slug: "",
      logo: window.DEFAULT_TEAM_LOGO || "./logo.png",
      color: ""
    };
  }

  function teamCellHtml(teamName){
    const name = safe(teamName) || "TBD";
    const meta = getMeta(name);

    const href = meta.slug ? `./team.html?team=${encodeURIComponent(meta.slug)}` : "#";
    const style = meta.color ? `style="color:${meta.color}"` : "";
    const logo = meta.logo || (window.DEFAULT_TEAM_LOGO || "./logo.png");
    const fallback = window.DEFAULT_TEAM_LOGO || "./logo.png";

    return `
      <div class="standingsTeamCell">
        <img class="standingsTeamLogo" src="${logo}" alt="${name} logo"
             onerror="this.onerror=null; this.src='${fallback}';">
        <a class="standingsTeamLink" ${style} href="${href}">${name}</a>
      </div>
    `;
  }

  function computePct(W, L, T){
    const gp = W + L + T;
    if (!gp) return 0;
    // baseball-style: ties count as half-win in pct
    return (W + 0.5*T) / gp;
  }

  function pctStr(p){
    // show like .667 or 1.000
    const s = p.toFixed(3);
    return s.startsWith("0") ? s.slice(1) : s;
  }

  // Streak tracking:
  // We compute by scanning games in chronological order per team
  // using Date then Time then Field then (optional) GameID.
  function gameSortKey(g){
    // string compare is fine because your Date is consistent; if not, still stable enough
    const d = safe(g.Date);
    const t = safe(g.Time);
    const f = safe(g.Field);
    const id = safe(g.Game || g.GameID || "");
    return `${d}__${t}__${f}__${id}`;
  }

  function resultForTeam(game, teamName){
    const a = safe(game.TeamA);
    const b = safe(game.TeamB);
    if (teamName !== a && teamName !== b) return null;
    if (!isFinal(game.Status)) return null;

    const sa = toNum(game.ScoreA);
    const sb = toNum(game.ScoreB);
    if (sa === null || sb === null) return null;

    if (sa === sb) return "T";
    const teamIsA = (teamName === a);
    const teamWon = teamIsA ? (sa > sb) : (sb > sa);
    return teamWon ? "W" : "L";
  }

  function computeStreaks(teamNames, finalGamesSorted){
    const streakMap = new Map();
    // initialize
    teamNames.forEach(n => streakMap.set(n, { type: "", count: 0 }));

    for (const g of finalGamesSorted){
      for (const teamName of teamNames){
        const res = resultForTeam(g, teamName);
        if (!res) continue;

        const s = streakMap.get(teamName) || { type:"", count:0 };
        if (!s.type) {
          s.type = res; s.count = 1;
        } else if (s.type === res) {
          s.count += 1;
        } else {
          s.type = res; s.count = 1;
        }
        streakMap.set(teamName, s);
      }
    }
    return streakMap;
  }

  function streakStr(s){
    if (!s || !s.type || !s.count) return "-";
    return `${s.type}${s.count}`;
  }

  function buildStandings(teamNames) {
    const map = new Map();
    for (const name of teamNames) {
      if (!name) continue;
      map.set(name, { team: name, W: 0, L: 0, T: 0, RF: 0, RA: 0, RD: 0, GP: 0, PCT: 0, STREAK: "-" });
    }
    return map;
  }

  function defaultCompare(a, b){
    // Default standings: PCT desc, L asc, RD desc, RF desc, team name asc
    if (b.PCT !== a.PCT) return b.PCT - a.PCT;
    if (a.L !== b.L) return a.L - b.L;
    if (b.RD !== a.RD) return b.RD - a.RD;
    if (b.RF !== a.RF) return b.RF - a.RF;
    return a.team.localeCompare(b.team);
  }

  function compareByKey(a, b){
    // numeric keys (except STREAK)
    if (sortKey === "STREAK") {
      // Sort by streak strength: W > T > L, then count desc
      const rank = (s) => {
        if (!s || s === "-") return { r: 0, n: 0 };
        const type = s[0];
        const n = Number(s.slice(1)) || 0;
        const r = type === "W" ? 3 : type === "T" ? 2 : 1;
        return { r, n };
      };
      const ra = rank(a.STREAK);
      const rb = rank(b.STREAK);
      if (rb.r !== ra.r) return rb.r - ra.r;
      if (rb.n !== ra.n) return rb.n - ra.n;
      return defaultCompare(a,b);
    }

    const va = a[sortKey];
    const vb = b[sortKey];

    if (vb !== va) return (vb - va); // default desc
    return defaultCompare(a,b);
  }

  function applySort(rows){
    const sorted = [...rows];

    // Default sort always available via sortKey=PCT
    sorted.sort((a,b) => {
      let cmp = compareByKey(a,b);
      if (sortDir === "asc") cmp = -cmp;
      return cmp;
    });

    return sorted;
  }

  function setSortHeaderState(){
    document.querySelectorAll(".sortTh").forEach(th => {
      th.classList.remove("sortActiveAsc","sortActiveDesc");
      if (th.dataset.sort === sortKey) {
        th.classList.add(sortDir === "asc" ? "sortActiveAsc" : "sortActiveDesc");
      }
    });
  }

  function renderRows(rows) {
    tbody.innerHTML = "";

    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      if (idx === 0) tr.classList.add("standingsTop1");
      if (idx === 1) tr.classList.add("standingsTop2");

      tr.innerHTML = `
        <td class="colTeam">${teamCellHtml(r.team)}</td>

        <td class="colNum">${r.W}</td>
        <td class="colNum">${r.L}</td>
        <td class="colNum">${r.T}</td>

        <td class="colNum">${r.GP}</td>
        <td class="colNum">${pctStr(r.PCT)}</td>

        <td class="colNum">${r.RF}</td>
        <td class="colNum">${r.RA}</td>
        <td class="colNum colRd">${r.RD > 0 ? "+" : ""}${r.RD}</td>

        <td class="colStreak">${r.STREAK}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  async function init() {
    msgEl.textContent = "";
    updatedEl.textContent = "";

    // Load Teams CSV for logo/color/slug AND to ensure all teams appear even before finals.
    const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
    const teamRows = parseCsv(teamsCsv);

    const teamNames = [];
    for (const r of teamRows){
      const name = safe(r.TeamName);
      if (!name) continue;

      teamNames.push(name);

      teamMeta.set(norm(name), {
        slug: safe(r.TeamSlug),
        logo: safe(r.TeamLogo) || (window.DEFAULT_TEAM_LOGO || "./logo.png"),
        color: safe(r.TeamColor) // optional
      });
    }

    const standings = buildStandings(teamNames);

    // Load Games CSV
    const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
    const gameRows = parseCsv(gamesCsv);

    const finalGames = gameRows.filter(g => isFinal(g.Status));
    // Sort finals chronologically for streak calculations
    const finalGamesSorted = [...finalGames].sort((a,b) => gameSortKey(a).localeCompare(gameSortKey(b)));

    // Compute W/L/T, RF/RA
    let counted = 0;

    for (const g of finalGames) {
      const aName = safe(g.TeamA);
      const bName = safe(g.TeamB);
      if (!aName || !bName) continue;

      const scoreA = toNum(g.ScoreA);
      const scoreB = toNum(g.ScoreB);
      if (scoreA === null || scoreB === null) continue;

      if (!standings.has(aName)) standings.set(aName, { team: aName, W:0, L:0, T:0, RF:0, RA:0, RD:0, GP:0, PCT:0, STREAK:"-" });
      if (!standings.has(bName)) standings.set(bName, { team: bName, W:0, L:0, T:0, RF:0, RA:0, RD:0, GP:0, PCT:0, STREAK:"-" });

      const a = standings.get(aName);
      const b = standings.get(bName);

      // Runs
      a.RF += scoreA; a.RA += scoreB;
      b.RF += scoreB; b.RA += scoreA;

      // W/L/T
      if (scoreA > scoreB) { a.W += 1; b.L += 1; }
      else if (scoreB > scoreA) { b.W += 1; a.L += 1; }
      else { a.T += 1; b.T += 1; }

      counted += 1;
    }

    // Compute derived fields
    for (const v of standings.values()){
      v.GP = v.W + v.L + v.T;
      v.RD = v.RF - v.RA;
      v.PCT = computePct(v.W, v.L, v.T);
    }

    // Streaks
    const streaks = computeStreaks(Array.from(standings.keys()), finalGamesSorted);
    for (const [teamName, s] of streaks.entries()){
      const row = standings.get(teamName);
      if (row) row.STREAK = streakStr(s);
    }

    // Build rows and apply current sort
    let rows = Array.from(standings.values());

    // Default is Win% desc
    sortKey = "PCT";
    sortDir = "desc";
    setSortHeaderState();

    rows = applySort(rows);
    renderRows(rows);

    updatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;
    msgEl.textContent = counted
      ? `Standings based on ${counted} final game(s).`
      : `No final games yet — standings will populate once games are marked Final.`;

    // Sorting handlers
    document.querySelectorAll(".sortTh").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (!key) return;

        if (sortKey === key) {
          sortDir = (sortDir === "desc") ? "asc" : "desc";
        } else {
          sortKey = key;
          sortDir = "desc";
        }

        setSortHeaderState();
        const sorted = applySort(Array.from(standings.values()));
        renderRows(sorted);
      });
    });
  }

  init().catch(err => {
    console.error(err);
    msgEl.textContent = "Standings error: " + err.message;
  });
</script>

<script src="./nav.js"></script>
</body>
</html>


