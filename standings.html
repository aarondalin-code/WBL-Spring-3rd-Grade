<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings • WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl2026-standings2" />
</head>

<body class="watermarkPage standingsPage hasHamburger">
<header class="siteHeader">
  <div class="navWrap">
    <button class="navToggle" type="button" aria-label="Open menu" aria-expanded="false" aria-controls="siteNav">
      <span></span><span></span><span></span>
    </button>

    <div class="navOverlay" aria-hidden="true"></div>

    <nav class="nav" id="siteNav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html" class="active">Standings</a>
      <a href="./teams.html">Teams</a>
      <a href="./playoffs.html">Playoffs</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>
  </div>

  <div class="brandCenter">
    <img src="./logo.png" alt="WBL Logo" class="logoImage" />
    <h1>WBL 3rd Grade 2026</h1>
    <div class="tagline">Standings</div>
  </div>
</header>

<main class="wrap">
  <section class="docSection">

    <div class="card">
      <div class="cardBody">

        <div class="standingsTopBar">
          <div>
            <div class="standingsTitle">Standings</div>
            <div class="muted small">
              Auto-calculated from games marked <strong>Final</strong> in your Google Sheet.
            </div>
          </div>
          <div class="standingsMeta muted small" id="standingsUpdated"></div>
        </div>

        <div class="tableScroll standingsTableScroll">
          <table id="standingsTable" class="standingsTableModern">
            <thead>
              <tr>
                <th class="colTeam">Team</th>
                <th class="colNum">W</th>
                <th class="colNum">L</th>
                <th class="colNum">T</th>
                <th class="colNum">RF</th>
                <th class="colNum">RA</th>
                <th class="colNum colRd">RD</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <p id="standingsMsg" class="muted small" style="margin-top:12px;"></p>

      </div>
    </div>

  </section>
</main>

<script src="./data.js"></script>

<script>
  const tbody = document.querySelector("#standingsTable tbody");
  const msgEl = document.getElementById("standingsMsg");
  const updatedEl = document.getElementById("standingsUpdated");

  // Teams meta from Teams CSV:
  // key: normalized TeamName -> { slug, logo, color }
  const teamMeta = new Map();

  function safe(v){ return String(v ?? "").trim(); }
  function norm(v){ return safe(v).toLowerCase(); }
  function isFinal(status){ return norm(status) === "final"; }

  function toNum(x){
    const n = Number(safe(x));
    return Number.isFinite(n) ? n : null;
  }

  async function fetchCsv(url) {
    if (!url) throw new Error("Missing CSV URL in data.js");
    const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(url + bust, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
    return await res.text();
  }

  // Robust CSV parser (quoted commas safe)
  function parseCsv(text) {
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (ch === '"') {
        if (inQuotes && next === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
        continue;
      }

      if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

      if (!inQuotes && (ch === "\n" || ch === "\r")) {
        if (ch === "\r" && next === "\n") i++;
        row.push(cur); cur = "";
        if (row.some(v => safe(v) !== "")) rows.push(row);
        row = [];
        continue;
      }

      cur += ch;
    }

    row.push(cur);
    if (row.some(v => safe(v) !== "")) rows.push(row);

    const headers = (rows.shift() || []).map(h => safe(h).replace(/\s+/g,""));
    return rows.map(r => {
      const obj = {};
      headers.forEach((h, idx) => obj[h] = safe(r[idx]));
      return obj;
    }).filter(o => Object.values(o).some(v => safe(v) !== ""));
  }

  function getMeta(teamName){
    const m = teamMeta.get(norm(teamName));
    return m || {
      slug: "",
      logo: window.DEFAULT_TEAM_LOGO || "./logo.png",
      color: ""
    };
  }

  function teamCellHtml(teamName){
    const name = safe(teamName) || "TBD";
    const meta = getMeta(name);

    const href = meta.slug ? `./team.html?team=${encodeURIComponent(meta.slug)}` : "#";
    const style = meta.color ? `style="color:${meta.color}"` : "";
    const logo = meta.logo || (window.DEFAULT_TEAM_LOGO || "./logo.png");
    const fallback = window.DEFAULT_TEAM_LOGO || "./logo.png";

    return `
      <div class="standingsTeamCell">
        <img class="standingsTeamLogo" src="${logo}" alt="${name} logo"
             onerror="this.onerror=null; this.src='${fallback}';">
        <a class="standingsTeamLink" ${style} href="${href}">${name}</a>
      </div>
    `;
  }

  function buildStandings(teamNames) {
    const map = new Map();
    for (const name of teamNames) {
      if (!name) continue;
      map.set(name, { team: name, W: 0, L: 0, T: 0, RF: 0, RA: 0, RD: 0 });
    }
    return map;
  }

  function sortStandings(a, b) {
    // W desc, L asc, RD desc, RF desc, team name asc
    if (b.W !== a.W) return b.W - a.W;
    if (a.L !== b.L) return a.L - b.L;
    if (b.RD !== a.RD) return b.RD - a.RD;
    if (b.RF !== a.RF) return b.RF - a.RF;
    return a.team.localeCompare(b.team);
  }

  function renderRows(rows) {
    tbody.innerHTML = "";

    rows.forEach((r, idx) => {
      const tr = document.createElement("tr");
      if (idx === 0) tr.classList.add("standingsTop1");
      if (idx === 1) tr.classList.add("standingsTop2");

      tr.innerHTML = `
        <td class="colTeam">${teamCellHtml(r.team)}</td>
        <td class="colNum">${r.W}</td>
        <td class="colNum">${r.L}</td>
        <td class="colNum">${r.T}</td>
        <td class="colNum">${r.RF}</td>
        <td class="colNum">${r.RA}</td>
        <td class="colNum colRd">${r.RD > 0 ? "+" : ""}${r.RD}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  async function init() {
    msgEl.textContent = "";
    updatedEl.textContent = "";

    // Load Teams CSV for logo/color/slug AND to ensure all teams appear even before finals.
    const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
    const teamRows = parseCsv(teamsCsv);

    const teamNames = [];
    for (const r of teamRows){
      const name = safe(r.TeamName);
      if (!name) continue;

      teamNames.push(name);

      teamMeta.set(norm(name), {
        slug: safe(r.TeamSlug),
        logo: safe(r.TeamLogo) || (window.DEFAULT_TEAM_LOGO || "./logo.png"),
        color: safe(r.TeamColor) // optional
      });
    }

    const standings = buildStandings(teamNames);

    // Load Games CSV
    const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
    const gameRows = parseCsv(gamesCsv);

    const finalGames = gameRows.filter(g => isFinal(g.Status));
    let counted = 0;

    for (const g of finalGames) {
      const aName = safe(g.TeamA);
      const bName = safe(g.TeamB);
      if (!aName || !bName) continue;

      const scoreA = toNum(g.ScoreA);
      const scoreB = toNum(g.ScoreB);
      if (scoreA === null || scoreB === null) continue;

      if (!standings.has(aName)) standings.set(aName, { team: aName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });
      if (!standings.has(bName)) standings.set(bName, { team: bName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });

      const a = standings.get(aName);
      const b = standings.get(bName);

      // Runs
      a.RF += scoreA; a.RA += scoreB;
      b.RF += scoreB; b.RA += scoreA;

      // W/L/T
      if (scoreA > scoreB) { a.W += 1; b.L += 1; }
      else if (scoreB > scoreA) { b.W += 1; a.L += 1; }
      else { a.T += 1; b.T += 1; }

      counted += 1;
    }

    // RD
    for (const v of standings.values()) v.RD = v.RF - v.RA;

    const rows = Array.from(standings.values()).sort(sortStandings);
    renderRows(rows);

    updatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;
    msgEl.textContent = counted
      ? `Standings based on ${counted} final game(s).`
      : `No final games yet — standings will populate once games are marked Final.`;
  }

  init().catch(err => {
    console.error(err);
    msgEl.textContent = "Standings error: " + err.message;
  });
</script>

<script src="./nav.js"></script>
</body>
</html>


