<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Standings • WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl2026-standings5" />
</head>

<body class="watermarkPage standingsPage hasHamburger">
<header class="siteHeader">
  <div class="navWrap">
    <button class="navToggle" type="button" aria-label="Open menu" aria-expanded="false" aria-controls="siteNav">
      <span></span><span></span><span></span>
    </button>

    <div class="navOverlay" aria-hidden="true"></div>

    <nav class="nav" id="siteNav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html" class="active">Standings</a>
      <a href="./teams.html">Teams</a>
      <a href="./playoffs.html">Playoffs</a>
      <a href="./practice.html">Practice Drills</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>
  </div>

  <div class="brandCenter">
    <img src="./logo.png" alt="WBL Logo" class="logoImage" />
    <h1>WBL 3rd Grade 2026</h1>
    <div class="tagline">Standings</div>
  </div>
</header>

<main class="wrap">
  <section class="docSection">
    <div class="card">
      <div class="cardBody">

        <div class="standingsTopBar">
          <div>
            <div class="standingsTitle">Standings</div>
            <div class="muted small">
              Auto-calculated from games marked <strong>Final</strong>. Click a column header to sort.
            </div>
          </div>
          <div class="standingsMeta muted small" id="standingsUpdated"></div>
        </div>

        <div class="tableScroll standingsTableScroll">
          <table id="standingsTable" class="standingsTableModern">
            <thead>
              <tr>
                <th class="colRank sortTh" data-sort="RANK">#</th>

                <!-- Team header aligned with logo + name column -->
                <th class="colTeam">
                  <div class="standingsTeamHeader">
                    <span class="standingsTeamHeaderSpacer" aria-hidden="true"></span>
                    <span>Team</span>
                  </div>
                </th>

                <th class="colNum sortTh" data-sort="W">W</th>
                <th class="colNum sortTh" data-sort="L">L</th>
                <th class="colNum sortTh" data-sort="T">T</th>

                <th class="colNum sortTh" data-sort="GP">GP</th>
                <th class="colNum sortTh" data-sort="PCT">Win%</th>

                <th class="colNum sortTh" data-sort="RF">RF</th>
                <th class="colNum sortTh" data-sort="RA">RA</th>
                <th class="colNum colRd sortTh" data-sort="RD">RD</th>

                <th class="colStreak sortTh" data-sort="STREAK">Streak</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <p id="standingsMsg" class="muted small" style="margin-top:12px;"></p>

      </div>
    </div>
  </section>
</main>

<script src="./data.js"></script>

<script>
  const tbody = document.querySelector("#standingsTable tbody");
  const msgEl = document.getElementById("standingsMsg");
  const updatedEl = document.getElementById("standingsUpdated");

  const PLAYOFF_CUTOFF = 6;

  // Show playoff cut line only after every team has played at least this many games.
  const SHOW_CUTLINE_AFTER_MIN_GP = 6;

  // Teams meta from Teams CSV:
  // key: normalized TeamName -> { slug, logo, color }
  const teamMeta = new Map();

  // Sort state
  let sortKey = "PCT";
  let sortDir = "desc"; // "asc" | "desc"

  // Cached base standings rows
  let baseRows = [];
  let clinchedSet = new Set();

  // Will be computed at init:
  let showCutLine = false;

  function safe(v){ return String(v ?? "").trim(); }
  function norm(v){ return safe(v).toLowerCase(); }
  function isFinal(status){ return norm(status) === "final"; }

  function toNum(x){
    const n = Number(safe(x));
    return Number.isFinite(n) ? n : null;
  }

  async function fetchCsv(url) {
    if (!url) throw new Error("Missing CSV URL in data.js");
    const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(url + bust, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
    return await res.text();
  }

  // Robust CSV parser (quoted commas safe)
  function parseCsv(text) {
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (ch === '"') {
        if (inQuotes && next === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
        continue;
      }

      if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

      if (!inQuotes && (ch === "\n" || ch === "\r")) {
        if (ch === "\r" && next === "\n") i++;
        row.push(cur); cur = "";
        if (row.some(v => safe(v) !== "")) rows.push(row);
        row = [];
        continue;
      }

      cur += ch;
    }

    row.push(cur);
    if (row.some(v => safe(v) !== "")) rows.push(row);

    const headers = (rows.shift() || []).map(h => safe(h).replace(/\s+/g,""));
    return rows.map(r => {
      const obj = {};
      headers.forEach((h, idx) => obj[h] = safe(r[idx]));
      return obj;
    }).filter(o => Object.values(o).some(v => safe(v) !== ""));
  }

  function getMeta(teamName){
    const m = teamMeta.get(norm(teamName));
    return m || {
      slug: "",
      logo: window.DEFAULT_TEAM_LOGO || "./logo.png",
      color: ""
    };
  }

  function teamCellHtml(teamName){
    const name = safe(teamName) || "TBD";
    const meta = getMeta(name);

    const href = meta.slug ? `./team.html?team=${encodeURIComponent(meta.slug)}` : "#";
    const style = meta.color ? `style="color:${meta.color}"` : "";
    const logo = meta.logo || (window.DEFAULT_TEAM_LOGO || "./logo.png");
    const fallback = window.DEFAULT_TEAM_LOGO || "./logo.png";

    const clinched = clinchedSet.has(name);
    const badge = clinched ? `<span class="clinchedBadge" title="Clinched a playoff spot">Clinched</span>` : "";

    return `
      <div class="standingsTeamCell">
        <img class="standingsTeamLogo" src="${logo}" alt="${name} logo"
             onerror="this.onerror=null; this.src='${fallback}';">
        <div class="standingsTeamText">
          <a class="standingsTeamLink" ${style} href="${href}">${name}</a>
          ${badge}
        </div>
      </div>
    `;
  }

  function computePct(W, L, T){
    const gp = W + L + T;
    if (!gp) return 0;
    return (W + 0.5*T) / gp;
  }

  function pctStr(p){
    const s = p.toFixed(3);
    return s.startsWith("0") ? s.slice(1) : s;
  }

  // "Points" used for clinch math (wins + 0.5 ties)
  function points(W, T){ return W + 0.5*T; }

  // Sorting key for streak calc: Date + Time + Field + GameID
  function gameSortKey(g){
    const d = safe(g.Date);
    const t = safe(g.Time);
    const f = safe(g.Field);
    const id = safe(g.Game || g.GameID || "");
    return `${d}__${t}__${f}__${id}`;
  }

  function resultForTeam(game, teamName){
    const a = safe(game.TeamA);
    const b = safe(game.TeamB);
    if (teamName !== a && teamName !== b) return null;
    if (!isFinal(game.Status)) return null;

    const sa = toNum(game.ScoreA);
    const sb = toNum(game.ScoreB);
    if (sa === null || sb === null) return null;

    if (sa === sb) return "T";
    const teamIsA = (teamName === a);
    const teamWon = teamIsA ? (sa > sb) : (sb > sa);
    return teamWon ? "W" : "L";
  }

  function computeStreaks(teamNames, finalGamesSorted){
    const streakMap = new Map();
    teamNames.forEach(n => streakMap.set(n, { type: "", count: 0 }));

    for (const g of finalGamesSorted){
      for (const teamName of teamNames){
        const res = resultForTeam(g, teamName);
        if (!res) continue;

        const s = streakMap.get(teamName) || { type:"", count:0 };
        if (!s.type) { s.type = res; s.count = 1; }
        else if (s.type === res) { s.count += 1; }
        else { s.type = res; s.count = 1; }

        streakMap.set(teamName, s);
      }
    }
    return streakMap;
  }

  function streakStr(s){
    if (!s || !s.type || !s.count) return "-";
    return `${s.type}${s.count}`;
  }

  // Conservative clinch logic:
  // A team is clinched if fewer than 6 OTHER teams can still reach (>=) its current points.
  function computeClinched(rows){
    const set = new Set();
    for (const x of rows){
      const xMin = x.PTS; // current points
      let threatCount = 0;
      for (const o of rows){
        if (o.team === x.team) continue;
        if (o.MAX_PTS >= xMin) threatCount += 1;
      }
      if (threatCount < PLAYOFF_CUTOFF) set.add(x.team);
    }
    return set;
  }

  function defaultCompare(a, b){
    if (b.PCT !== a.PCT) return b.PCT - a.PCT;
    if (a.L !== b.L) return a.L - b.L;
    if (b.RD !== a.RD) return b.RD - a.RD;
    if (b.RF !== a.RF) return b.RF - a.RF;
    return a.team.localeCompare(b.team);
  }

  function compareByKey(a, b){
    if (sortKey === "RANK") return defaultCompare(a,b);

    if (sortKey === "STREAK") {
      const rank = (s) => {
        if (!s || s === "-") return { r: 0, n: 0 };
        const type = s[0];
        const n = Number(s.slice(1)) || 0;
        const r = type === "W" ? 3 : type === "T" ? 2 : 1;
        return { r, n };
      };
      const ra = rank(a.STREAK);
      const rb = rank(b.STREAK);
      if (rb.r !== ra.r) return rb.r - ra.r;
      if (rb.n !== ra.n) return rb.n - ra.n;
      return defaultCompare(a,b);
    }

    const va = a[sortKey];
    const vb = b[sortKey];
    if (vb !== va) return (vb - va);
    return defaultCompare(a,b);
  }

  function applySort(rows){
    const sorted = [...rows];
    sorted.sort((a,b) => {
      let cmp = compareByKey(a,b);
      if (sortDir === "asc") cmp = -cmp;
      return cmp;
    });
    return sorted;
  }

  function setSortHeaderState(){
    document.querySelectorAll(".sortTh").forEach(th => {
      th.classList.remove("sortActiveAsc","sortActiveDesc");
      if (th.dataset.sort === sortKey) {
        th.classList.add(sortDir === "asc" ? "sortActiveAsc" : "sortActiveDesc");
      }
    });
  }

  function renderRows(sortedRows) {
    tbody.innerHTML = "";

    sortedRows.forEach((r, idx) => {
      const tr = document.createElement("tr");

      if (idx === 0) tr.classList.add("standingsTop1");
      if (idx === 1) tr.classList.add("standingsTop2");

      // Only highlight top 6 after week 6 (min GP >= 6)
      if (showCutLine && idx < PLAYOFF_CUTOFF) tr.classList.add("playoffRow");

      tr.innerHTML = `
        <td class="colRank">${idx + 1}</td>
        <td class="colTeam">${teamCellHtml(r.team)}</td>

        <td class="colNum">${r.W}</td>
        <td class="colNum">${r.L}</td>
        <td class="colNum">${r.T}</td>

        <td class="colNum">${r.GP}</td>
        <td class="colNum">${pctStr(r.PCT)}</td>

        <td class="colNum">${r.RF}</td>
        <td class="colNum">${r.RA}</td>
        <td class="colNum colRd">${r.RD > 0 ? "+" : ""}${r.RD}</td>

        <td class="colStreak">${r.STREAK}</td>
      `;
      tbody.appendChild(tr);

      // Only show cut line after week 6 threshold
      if (showCutLine && idx === PLAYOFF_CUTOFF - 1){
        const cut = document.createElement("tr");
        cut.className = "cutLineRow";
        cut.innerHTML = `<td colspan="11"><span class="cutLineLabel">Playoff Cut Line</span></td>`;
        tbody.appendChild(cut);
      }
    });
  }

  async function init() {
    msgEl.textContent = "";
    updatedEl.textContent = "";

    // Load Teams CSV
    const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
    const teamRows = parseCsv(teamsCsv);

    const teamNames = [];
    for (const r of teamRows){
      const name = safe(r.TeamName);
      if (!name) continue;

      teamNames.push(name);
      teamMeta.set(norm(name), {
        slug: safe(r.TeamSlug),
        logo: safe(r.TeamLogo) || (window.DEFAULT_TEAM_LOGO || "./logo.png"),
        color: safe(r.TeamColor) // optional
      });
    }

    // Load Games CSV
    const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
    const gameRows = parseCsv(gamesCsv);

    // Compute total scheduled games per team from the games sheet itself
    const totalByTeam = new Map();
    const finalsPlayedByTeam = new Map();

    function bump(map, key, amt=1){
      map.set(key, (map.get(key) || 0) + amt);
    }

    for (const g of gameRows){
      const a = safe(g.TeamA);
      const b = safe(g.TeamB);
      if (a) bump(totalByTeam, a, 1);
      if (b) bump(totalByTeam, b, 1);

      if (isFinal(g.Status)){
        if (a) bump(finalsPlayedByTeam, a, 1);
        if (b) bump(finalsPlayedByTeam, b, 1);
      }
    }

    // Build standings
    const standings = new Map();
    for (const name of teamNames){
      standings.set(name, {
        team: name, W:0, L:0, T:0, RF:0, RA:0, RD:0,
        GP:0, PCT:0, STREAK:"-",
        PTS:0, REM:0, MAX_PTS:0
      });
    }

    const finalGames = gameRows.filter(g => isFinal(g.Status));
    const finalGamesSorted = [...finalGames].sort((a,b) => gameSortKey(a).localeCompare(gameSortKey(b)));

    let counted = 0;

    for (const g of finalGames) {
      const aName = safe(g.TeamA);
      const bName = safe(g.TeamB);
      if (!aName || !bName) continue;

      const scoreA = toNum(g.ScoreA);
      const scoreB = toNum(g.ScoreB);
      if (scoreA === null || scoreB === null) continue;

      if (!standings.has(aName)) standings.set(aName, { team:aName, W:0,L:0,T:0,RF:0,RA:0,RD:0,GP:0,PCT:0,STREAK:"-",PTS:0,REM:0,MAX_PTS:0 });
      if (!standings.has(bName)) standings.set(bName, { team:bName, W:0,L:0,T:0,RF:0,RA:0,RD:0,GP:0,PCT:0,STREAK:"-",PTS:0,REM:0,MAX_PTS:0 });

      const a = standings.get(aName);
      const b = standings.get(bName);

      a.RF += scoreA; a.RA += scoreB;
      b.RF += scoreB; b.RA += scoreA;

      if (scoreA > scoreB) { a.W += 1; b.L += 1; }
      else if (scoreB > scoreA) { b.W += 1; a.L += 1; }
      else { a.T += 1; b.T += 1; }

      counted += 1;
    }

    for (const v of standings.values()){
      v.GP = v.W + v.L + v.T;
      v.RD = v.RF - v.RA;
      v.PCT = computePct(v.W, v.L, v.T);

      v.PTS = points(v.W, v.T);

      const total = totalByTeam.get(v.team) || 0;
      const finalsPlayed = finalsPlayedByTeam.get(v.team) || 0;
      v.REM = Math.max(0, total - finalsPlayed);

      v.MAX_PTS = v.PTS + v.REM;
    }

    // Streaks
    const streaks = computeStreaks(Array.from(standings.keys()), finalGamesSorted);
    for (const [teamName, s] of streaks.entries()){
      const row = standings.get(teamName);
      if (row) row.STREAK = streakStr(s);
    }

    baseRows = Array.from(standings.values());

    // Gate playoff cut line until week 6 threshold is met (min GP across teams)
    const minGamesPlayed = baseRows.reduce((m, r) => Math.min(m, r.GP), Infinity);
    showCutLine = (minGamesPlayed >= SHOW_CUTLINE_AFTER_MIN_GP);

    // Default sort: Win%
    sortKey = "PCT";
    sortDir = "desc";
    setSortHeaderState();

    // Clinched set (does not depend on cut line)
    clinchedSet = computeClinched(baseRows);

    const sorted = applySort(baseRows);
    renderRows(sorted);

    updatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;
    msgEl.textContent = counted
      ? `Standings based on ${counted} final game(s).`
      : `No final games yet — standings will populate once games are marked Final.`;

    // Sorting handlers
    document.querySelectorAll(".sortTh").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.dataset.sort;
        if (!key) return;

        if (sortKey === key) sortDir = (sortDir === "desc") ? "asc" : "desc";
        else { sortKey = key; sortDir = "desc"; }

        setSortHeaderState();
        const resorted = applySort(baseRows);
        renderRows(resorted);
      });
    });
  }

  init().catch(err => {
    console.error(err);
    msgEl.textContent = "Standings error: " + err.message;
  });
</script>

<script src="./nav.js"></script>
</body>
</html>


