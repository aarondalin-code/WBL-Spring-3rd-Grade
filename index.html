<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl-home-v4" />
</head>

<body class="watermarkPage hasHamburger">
  <header class="siteHeader">
    <div class="navWrap">
      <button class="navToggle" type="button" aria-label="Open menu" aria-expanded="false" aria-controls="siteNav">
        <span></span><span></span><span></span>
      </button>

      <div class="navOverlay" aria-hidden="true"></div>

      <nav class="nav" id="siteNav">
        <a href="./" class="active">Home</a>
        <a href="./schedule.html">Schedule/Scores</a>
        <a href="./standings.html">Standings</a>
        <a href="./playoffs.html">Playoffs</a>
        <a href="./teams.html">Teams</a>
        <a href="./rules.html">Rules</a>
        <a href="./contacts.html">Contacts</a>
        <a href="./gallery.html">Gallery</a>
        <a href="./uploads.html">Uploads</a>
      </nav>
    </div>

    <div class="brandCenter">
      <img src="./logo.png" alt="WBL Logo" class="logoImage" />
      <h1>WBL 3rd Grade 2026</h1>
      <div class="tagline">Spring League Central</div>
    </div>
  </header>

  <main class="wrap">

    <!-- Welcome + Countdown -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeWelcome">
            <div class="muted" id="welcomeLine">
              Games Saturdays at <strong>10:00 AM</strong> and <strong>12:15 PM</strong> on fields <strong>T3, T4, T5</strong>.
            </div>

            <div class="homeCountdown" aria-live="polite" aria-atomic="true">
              <div class="homeCountdownLabel muted small" id="countdownLabel">Countdown to Opening Day (Apr 11)</div>
              <div class="homeCountdownTimer" id="countdownTimer">Loading…</div>
            </div>

            <div class="homeHeroBtns">
              <a class="btnPrimary" href="./schedule.html">This Week’s Games</a>
              <a class="btnSecondary" href="./standings.html">Standings</a>
              <a class="btnSecondary" href="./uploads.html">Upload Photos/Videos</a>
            </div>

            <div id="homeBannerNote" class="muted small" style="margin-top:12px; display:none;"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- This week + last week (rendered to mirror schedule.html cards) -->
    <section class="docSection">
      <div class="homeTwoCol">
        <div class="card">
          <div class="cardBody">
            <div class="homeSectionHead">
              <h3 style="margin:0;" id="thisWeekTitle">This Week</h3>
              <a class="linkPill" href="./schedule.html">Full Schedule →</a>
            </div>
            <div id="thisWeekGames" class="muted small">Loading…</div>
          </div>
        </div>

        <div class="card">
          <div class="cardBody">
            <div class="homeSectionHead">
              <h3 style="margin:0;" id="lastWeekTitle">Last Week (Finals)</h3>
              <a class="linkPill" href="./schedule.html">Scores →</a>
            </div>
            <div id="lastWeekFinals" class="muted small">Loading…</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Standings snapshot -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeSectionHead">
            <h3 style="margin:0;">Standings Snapshot (Top 4)</h3>
            <a class="linkPill" href="./standings.html">View Full Standings →</a>
          </div>

          <div class="tableScroll" style="margin-top:10px;">
            <table class="standingsTable" id="standingsMini">
              <thead>
                <tr>
                  <th class="num">#</th>
                  <th>Team</th>
                  <th class="num">W</th>
                  <th class="num">L</th>
                  <th class="num">T</th>
                  <th class="num">Win%</th>
                  <th class="num">Streak</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <p id="standingsMiniMsg" class="muted small" style="margin-top:10px;"></p>
        </div>
      </div>
    </section>

    <!-- Players of the Week -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeSectionHead">
            <div>
              <h3 style="margin:0;">Players of the Week</h3>
              <div class="muted small">One player per team — updated weekly.</div>
            </div>
          </div>

          <div id="potwGrid" class="potwGrid homePotwGrid" style="margin-top:12px;"></div>
          <p id="potwMsg" class="muted small" style="margin-top:10px;"></p>
        </div>
      </div>
    </section>

    <!-- Poll of the Week -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeSectionHead">
            <div>
              <h3 style="margin:0;">Poll of the Week</h3>
              <div class="muted small" id="pollSubtitle">Vote once per device.</div>
            </div>
          </div>

          <div id="pollWrap" style="margin-top:12px;">
            <div id="pollQuestion" style="font-weight:800; margin-bottom:10px;">Loading…</div>
            <div id="pollOptions" class="pollOptions"></div>

            <div class="pollActions" style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
              <button id="pollVoteBtn" class="btnPrimary" type="button">Vote</button>
              <button id="pollViewBtn" class="btnSecondary" type="button">View Results</button>
              <button id="pollChangeBtn" class="btnSecondary" type="button" style="display:none;">Change Vote</button>
            </div>

            <div id="pollMsg" class="muted small" style="margin-top:10px;"></div>
            <div id="pollResults" style="margin-top:12px; display:none;"></div>
          </div>
        </div>
      </div>
    </section>

  </main>

  <!-- Modal -->
  <div id="modalOverlay" class="modalOverlay" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <button class="modalClose" id="modalCloseBtn" type="button">✕</button>
      <div id="modalContent"></div>
    </div>
  </div>

  <script src="./data.js"></script>
  <script>
    function safe(v){ return String(v ?? "").trim(); }
    function norm(v){ return safe(v).toLowerCase(); }
    function isFinal(status){ return norm(status) === "final"; }

    function parseDateLoose(s){
      s = safe(s);
      if (!s) return null;

      const d1 = new Date(s);
      if (!isNaN(d1.getTime())) return d1;

      const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (m){
        const mm = Number(m[1]) - 1, dd = Number(m[2]), yy = Number(m[3]);
        const d2 = new Date(yy, mm, dd);
        return isNaN(d2.getTime()) ? null : d2;
      }
      return null;
    }

    async function fetchCsv(url){
      if (!url) throw new Error("Missing CSV URL in data.js");
      const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
      const res = await fetch(url + bust, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
      return await res.text();
    }

    // Robust CSV parser (quoted commas safe)
    function parseCsv(text){
      const rows = [];
      let row = [], cur = "", inQuotes = false;

      for (let i=0;i<text.length;i++){
        const ch = text[i], next = text[i+1];
        if (ch === '"'){
          if (inQuotes && next === '"'){ cur += '"'; i++; }
          else inQuotes = !inQuotes;
          continue;
        }
        if (!inQuotes && ch === ","){ row.push(cur); cur=""; continue; }
        if (!inQuotes && (ch === "\n" || ch === "\r")){
          if (ch === "\r" && next === "\n") i++;
          row.push(cur); cur="";
          if (row.some(v => safe(v)!=="")) rows.push(row);
          row=[]; continue;
        }
        cur += ch;
      }
      row.push(cur);
      if (row.some(v => safe(v)!=="")) rows.push(row);

      const headers = (rows.shift()||[]).map(h => safe(h).replace(/\s+/g,""));
      return rows.map(r => {
        const o = {};
        headers.forEach((h,idx)=> o[h]=safe(r[idx]));
        return o;
      }).filter(o => Object.values(o).some(v => safe(v) !== ""));
    }

    // Modal
    const overlay = document.getElementById("modalOverlay");
    const modalContent = document.getElementById("modalContent");
    const closeBtn = document.getElementById("modalCloseBtn");

    function openModal(html){
      modalContent.innerHTML = html;
      overlay.classList.add("open");
      document.body.classList.add("noScroll");
      overlay.setAttribute("aria-hidden","false");
    }
    function closeModal(){
      overlay.classList.remove("open");
      document.body.classList.remove("noScroll");
      overlay.setAttribute("aria-hidden","true");
      modalContent.innerHTML = "";
    }
    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", (e)=>{ if (e.target === overlay) closeModal(); });
    document.addEventListener("keydown",(e)=>{ if (e.key === "Escape") closeModal(); });

    function renderPlayerModal(player){
      const name = safe(player.PlayerName || player.Name || "Player");
      const team = safe(player.Team || player.TeamName || "");
      const photo = safe(player.PhotoURL) || (window.DEFAULT_PLAYER_PHOTO || "./logo.png");
      const blurb = safe(player.Blurb || player.Why || player.Reason || player.Notes || "");
      const coach = safe(player.CoachName);

      openModal(`
        <div class="profileHeader">
          <div class="profilePhoto">
            <img src="${photo}" alt="${name}" onerror="this.onerror=null; this.src='${window.DEFAULT_PLAYER_PHOTO || "./logo.png"}';">
          </div>
          <div>
            <h3 id="modalTitle" class="profileName">${name}</h3>
            ${team ? `<div class="muted" style="margin-top:4px;">${team}</div>` : ""}
            <div class="card" style="margin-top:12px;">
              <div class="cardBody">
                <div class="muted small">Coach’s Note${coach ? ` • ${coach}` : ""}</div>
                <div style="margin-top:6px;">${blurb || "Write-up coming soon."}</div>
              </div>
            </div>
          </div>
        </div>
      `);
    }

    // ---- Opening Day + weekly anchor logic ----
    const LEAGUE_START_DATE = new Date(2026, 3, 11); // Apr 11, 2026
    const LEAGUE_START_GAME_TIME = "10:00 AM";

    function openingCountdownTarget(){
      const d = new Date(LEAGUE_START_DATE.getFullYear(), LEAGUE_START_DATE.getMonth(), LEAGUE_START_DATE.getDate());
      const dt = new Date(`${d.toDateString()} ${LEAGUE_START_GAME_TIME}`);
      return isNaN(dt.getTime()) ? d : dt;
    }

    function saturdayFor(date){
      const d = new Date(date);
      const day = d.getDay(); // 0 Sun ... 6 Sat
      const daysUntilSat = (6 - day + 7) % 7;
      const sat = new Date(d.getFullYear(), d.getMonth(), d.getDate() + daysUntilSat);
      sat.setHours(0,0,0,0);
      return sat;
    }

    function getDisplaySaturday(now){
      const openingSat = new Date(LEAGUE_START_DATE.getFullYear(), LEAGUE_START_DATE.getMonth(), LEAGUE_START_DATE.getDate());
      openingSat.setHours(0,0,0,0);
      if (now.getTime() < openingSat.getTime()) return openingSat;
      return saturdayFor(now);
    }

    function fmtCountdown(ms){
      const total = Math.max(0, ms);
      const sec = Math.floor(total / 1000);
      const days = Math.floor(sec / 86400);
      const hrs = Math.floor((sec % 86400) / 3600);
      const mins = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const pad = (n)=> String(n).padStart(2,"0");
      return `${days}d ${pad(hrs)}h ${pad(mins)}m ${pad(s)}s`;
    }

    function updateCountdown(){
      const labelEl = document.getElementById("countdownLabel");
      const timerEl = document.getElementById("countdownTimer");
      if (!labelEl || !timerEl) return;

      const now = new Date();
      const openingTarget = openingCountdownTarget();

      if (now.getTime() < openingTarget.getTime()){
        labelEl.textContent = "Countdown to Opening Day (Apr 11)";
        timerEl.textContent = fmtCountdown(openingTarget.getTime() - now.getTime());
        return;
      }

      const nextSat = getDisplaySaturday(now);
      const nextGame = new Date(`${nextSat.toDateString()} ${LEAGUE_START_GAME_TIME}`);
      labelEl.textContent = "Countdown to Next Game Day";
      timerEl.textContent = fmtCountdown(nextGame.getTime() - now.getTime());
    }

    // ---- Teams meta + link helpers (mirrors schedule.html) ----
    // key: normalized TeamName -> { slug, logo, color }
    const teamMeta = new Map();

    function getMeta(teamName){
      const m = teamMeta.get(norm(teamName));
      return m || {
        slug: "",
        logo: window.DEFAULT_TEAM_LOGO || "./logo.png",
        color: ""
      };
    }

    function teamHref(teamName){
      const m = getMeta(teamName);
      return m.slug ? `./team.html?team=${encodeURIComponent(m.slug)}` : "./teams.html";
    }

    function teamAnchor(teamName){
      const name = safe(teamName) || "TBD";
      const m = getMeta(name);
      const href = teamHref(name);
      const style = m.color ? `style="color:${m.color}"` : "";
      return `<a class="scheduleTeamLink" ${style} href="${href}">${name}</a>`;
    }

    // ---- Schedule snapshot renderer (uses same markup/classes as schedule.html cards) ----
    function renderScheduleCard(g){
      const aName = safe(g.TeamA);
      const bName = safe(g.TeamB);
      const aMeta = getMeta(aName);
      const bMeta = getMeta(bName);

      const final = isFinal(g.Status);
      const hasScores = safe(g.ScoreA) !== "" && safe(g.ScoreB) !== "";
      const scoreText = (final && hasScores) ? `${safe(g.ScoreA)}–${safe(g.ScoreB)}` : "";

      const classes = `scheduleGameCard${final ? " finalGame" : ""}`;

      return `
        <div class="${classes}">
          <div class="scheduleGameMeta">
            <div>${safe(g.Time) || ""}</div>
            <div>${safe(g.Field) || ""}</div>
          </div>

          <div class="scheduleMatchupGrid">
            <div class="scheduleTeam sideLeft">
              <img class="teamLogo" src="${aMeta.logo}" alt="${aName} logo"
                   onerror="this.onerror=null; this.src='${window.DEFAULT_TEAM_LOGO || "./logo.png"}';">
              ${teamAnchor(aName)}
            </div>

            <div class="scheduleScore">
              ${scoreText || `<span class="vsLabel">@</span>`}
            </div>

            <div class="scheduleTeam sideRight">
              <img class="teamLogo" src="${bMeta.logo}" alt="${bName} logo"
                   onerror="this.onerror=null; this.src='${window.DEFAULT_TEAM_LOGO || "./logo.png"}';">
              ${teamAnchor(bName)}
            </div>
          </div>

          <div class="scheduleStatus">
            ${final ? `<span class="pillFinal">Final</span>` : (safe(g.Status) || "Scheduled")}
          </div>
        </div>
      `;
    }

    // ---- Standings calculations ----
    function toNum(x){
      const n = Number(safe(x));
      return Number.isFinite(n) ? n : null;
    }

    function calcPct(W,L,T){
      const gp = W + L + T;
      if (!gp) return 0;
      return (W + 0.5*T) / gp;
    }

    function fmtPct(p){
      return (p * 100).toFixed(1);
    }

    function buildStreaksFromFinals(games){
      const byTeam = new Map();

      function pushResult(team, res){
        if (!team) return;
        if (!byTeam.has(team)) byTeam.set(team, []);
        byTeam.get(team).push(res);
      }

      const finals = games
        .filter(g => isFinal(g.Status))
        .map(g => ({ g, d: parseDateLoose(g.Date) }))
        .filter(x => x.d)
        .sort((a,b)=> a.d - b.d)
        .map(x => x.g);

      for (const g of finals){
        const a = safe(g.TeamA), b = safe(g.TeamB);
        const sa = toNum(g.ScoreA), sb = toNum(g.ScoreB);
        if (!a || !b || sa===null || sb===null) continue;

        if (sa > sb){ pushResult(a,"W"); pushResult(b,"L"); }
        else if (sb > sa){ pushResult(b,"W"); pushResult(a,"L"); }
        else { pushResult(a,"T"); pushResult(b,"T"); }
      }

      const streak = new Map();
      for (const [team, arr] of byTeam.entries()){
        if (!arr.length){ streak.set(team,"—"); continue; }
        const last = arr[arr.length-1];
        let n = 1;
        for (let i=arr.length-2; i>=0; i--){
          if (arr[i] === last) n++;
          else break;
        }
        streak.set(team, `${last}${n}`);
      }
      return streak;
    }

    // ---- Poll of the Week (localStorage) ----
    const POLL = {
      // Change these anytime (weekKey should change weekly so results reset naturally)
      weekKey: "2026-Week-1", // e.g., "2026-Week-1" or "2026-04-11"
      question: "Which team will start the season 1–0?",
      options: [
        "No vote yet — just excited!",
        "Team A",
        "Team B",
        "Team C",
        "Team D"
      ]
    };

    function pollStorageKey(){
      return `wbl_poll_${POLL.weekKey}`;
    }

    function pollVoteKey(){
      return `wbl_poll_vote_${POLL.weekKey}`;
    }

    function loadPollCounts(){
      try{
        const raw = localStorage.getItem(pollStorageKey());
        const obj = raw ? JSON.parse(raw) : null;
        if (obj && Array.isArray(obj.counts) && obj.counts.length === POLL.options.length) return obj.counts;
      } catch(e){}
      return new Array(POLL.options.length).fill(0);
    }

    function savePollCounts(counts){
      localStorage.setItem(pollStorageKey(), JSON.stringify({ counts }));
    }

    function loadMyVote(){
      return safe(localStorage.getItem(pollVoteKey()));
    }

    function saveMyVote(idx){
      localStorage.setItem(pollVoteKey(), String(idx));
    }

    function clearMyVote(){
      localStorage.removeItem(pollVoteKey());
    }

    function renderPoll(){
      const qEl = document.getElementById("pollQuestion");
      const optEl = document.getElementById("pollOptions");
      const msgEl = document.getElementById("pollMsg");
      const resEl = document.getElementById("pollResults");
      const subEl = document.getElementById("pollSubtitle");
      const voteBtn = document.getElementById("pollVoteBtn");
      const viewBtn = document.getElementById("pollViewBtn");
      const changeBtn = document.getElementById("pollChangeBtn");

      qEl.textContent = POLL.question;
      subEl.textContent = `Week: ${POLL.weekKey} • Vote once per device.`;

      optEl.innerHTML = "";
      msgEl.textContent = "";
      resEl.style.display = "none";
      resEl.innerHTML = "";

      const myVote = loadMyVote();
      const myIdx = myVote !== "" ? Number(myVote) : null;
      const hasVoted = Number.isFinite(myIdx) && myIdx >= 0;

      POLL.options.forEach((label, idx) => {
        const id = `pollOpt_${idx}`;
        const wrap = document.createElement("label");
        wrap.className = "pollOpt";
        wrap.setAttribute("for", id);
        wrap.innerHTML = `
          <input type="radio" name="pollOpt" id="${id}" value="${idx}" ${hasVoted && idx === myIdx ? "checked" : ""} ${hasVoted ? "disabled" : ""}>
          <span>${label}</span>
        `;
        optEl.appendChild(wrap);
      });

      if (hasVoted){
        msgEl.textContent = `You voted: ${POLL.options[myIdx]}`;
        voteBtn.disabled = true;
        changeBtn.style.display = "";
      } else {
        voteBtn.disabled = false;
        changeBtn.style.display = "none";
      }

      viewBtn.onclick = () => {
        renderPollResults();
      };

      voteBtn.onclick = () => {
        const selected = document.querySelector('input[name="pollOpt"]:checked');
        if (!selected){
          msgEl.textContent = "Pick an option first.";
          return;
        }
        const idx = Number(selected.value);
        if (!Number.isFinite(idx)) return;

        const counts = loadPollCounts();
        counts[idx] = (counts[idx] || 0) + 1;
        savePollCounts(counts);
        saveMyVote(idx);

        renderPoll();
        renderPollResults(true);
      };

      changeBtn.onclick = () => {
        // Let them re-vote (decrement prior vote, then allow selection)
        const myVote2 = loadMyVote();
        const priorIdx = myVote2 !== "" ? Number(myVote2) : null;
        if (Number.isFinite(priorIdx) && priorIdx >= 0){
          const counts = loadPollCounts();
          counts[priorIdx] = Math.max(0, (counts[priorIdx] || 0) - 1);
          savePollCounts(counts);
        }
        clearMyVote();
        renderPoll();
        msgEl.textContent = "Vote changed — pick a new option.";
      };
    }

    function renderPollResults(keepOpen){
      const resEl = document.getElementById("pollResults");
      const counts = loadPollCounts();
      const total = counts.reduce((a,b)=>a+(b||0),0);

      resEl.style.display = "";
      resEl.innerHTML = `
        <div class="muted small" style="margin-bottom:8px;">Total votes: ${total}</div>
        ${POLL.options.map((label, idx) => {
          const c = counts[idx] || 0;
          const pct = total ? Math.round((c / total) * 100) : 0;
          return `
            <div class="pollResultRow">
              <div class="pollResultTop">
                <div style="font-weight:800;">${label}</div>
                <div class="muted small">${c} (${pct}%)</div>
              </div>
              <div class="pollBar">
                <div class="pollBarFill" style="width:${pct}%;"></div>
              </div>
            </div>
          `;
        }).join("")}
      `;

      if (!keepOpen){
        document.getElementById("pollMsg").textContent = "";
      }
    }

    async function initHome(){
      // Countdown timer
      updateCountdown();
      setInterval(updateCountdown, 1000);

      // Poll
      renderPoll();

      // Load teams for slug/logo/color (headers: TeamName, TeamSlug, TeamLogo, TeamColor)
      try{
        const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
        const teamRows = parseCsv(teamsCsv);

        for (const r of teamRows){
          const name = safe(r.TeamName);
          if (!name) continue;

          teamMeta.set(norm(name), {
            slug: safe(r.TeamSlug),
            logo: safe(r.TeamLogo) || (window.DEFAULT_TEAM_LOGO || "./logo.png"),
            color: safe(r.TeamColor) || ""
          });
        }

        // Optional: if poll options are placeholder ("Team A"...), swap them to real teams automatically
        // Keep the first "fun" option, then fill with 4 alphabetically.
        if (POLL.options.some(o => /^Team [A-D]$/.test(o))){
          const names = teamRows.map(r => safe(r.TeamName)).filter(Boolean).sort();
          const filled = [POLL.options[0], ...names.slice(0,4)];
          if (filled.length === POLL.options.length) POLL.options = filled;
          renderPoll();
        }
      } catch(e){
        console.warn("Teams feed unavailable.", e);
      }

      // Load games
      const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
      const games = parseCsv(gamesCsv);

      // Determine which Saturday we're showing
      const now = new Date();
      const thisSat = getDisplaySaturday(now);
      const lastSat = new Date(thisSat.getFullYear(), thisSat.getMonth(), thisSat.getDate() - 7);
      lastSat.setHours(0,0,0,0);

      const thisWeekTitle = document.getElementById("thisWeekTitle");
      const bannerNote = document.getElementById("homeBannerNote");

      const openingSat = new Date(LEAGUE_START_DATE.getFullYear(), LEAGUE_START_DATE.getMonth(), LEAGUE_START_DATE.getDate());
      openingSat.setHours(0,0,0,0);

      const fmtShort = (d)=> d.toLocaleDateString(undefined, { month:"short", day:"numeric" });

      if (now.getTime() < openingSat.getTime()){
        thisWeekTitle.textContent = `Opening Day (${fmtShort(thisSat)})`;
        bannerNote.textContent = `Showing Opening Day games on ${fmtShort(thisSat)}.`;
        bannerNote.style.display = "";
      } else {
        thisWeekTitle.textContent = `This Week (${fmtShort(thisSat)})`;
        bannerNote.style.display = "none";
      }

      // Partition games by date = thisSat / lastSat
      const thisWeek = [];
      const lastWeekFinals = [];

      for (const g of games){
        const d = parseDateLoose(g.Date);
        if (!d) continue;
        d.setHours(0,0,0,0);

        if (d.getTime() === thisSat.getTime()){
          thisWeek.push(g);
        }
        if (d.getTime() === lastSat.getTime() && isFinal(g.Status)){
          lastWeekFinals.push(g);
        }
      }

      const thisEl = document.getElementById("thisWeekGames");
      thisEl.innerHTML = thisWeek.length
        ? thisWeek.map(renderScheduleCard).join("")
        : `<div class="muted small">No games found for ${fmtShort(thisSat)} yet.</div>`;

      const lastEl = document.getElementById("lastWeekFinals");
      lastEl.innerHTML = lastWeekFinals.length
        ? lastWeekFinals.map(renderScheduleCard).join("")
        : `<div class="muted small">No final games from ${fmtShort(lastSat)} yet.</div>`;

      // Standings snapshot (Top 4)
      const teamsSet = new Set();
      games.forEach(g => {
        if (safe(g.TeamA)) teamsSet.add(safe(g.TeamA));
        if (safe(g.TeamB)) teamsSet.add(safe(g.TeamB));
      });

      const table = new Map();
      for (const t of teamsSet) table.set(t, { team:t, W:0, L:0, T:0 });

      let finalsCount = 0;
      for (const g of games){
        if (!isFinal(g.Status)) continue;
        const a = safe(g.TeamA), b = safe(g.TeamB);
        const sa = toNum(g.ScoreA), sb = toNum(g.ScoreB);
        if (!a || !b || sa===null || sb===null) continue;

        if (!table.has(a)) table.set(a,{team:a,W:0,L:0,T:0});
        if (!table.has(b)) table.set(b,{team:b,W:0,L:0,T:0});

        if (sa > sb){ table.get(a).W++; table.get(b).L++; }
        else if (sb > sa){ table.get(b).W++; table.get(a).L++; }
        else { table.get(a).T++; table.get(b).T++; }

        finalsCount++;
      }

      const rows = Array.from(table.values()).sort((x,y)=>{
        const xp = calcPct(x.W,x.L,x.T);
        const yp = calcPct(y.W,y.L,y.T);
        if (yp !== xp) return yp - xp;
        if (y.W !== x.W) return y.W - x.W;
        if (x.L !== y.L) return x.L - y.L;
        return x.team.localeCompare(y.team);
      });

      const streakMap = buildStreaksFromFinals(games);
      const miniBody = document.querySelector("#standingsMini tbody");
      miniBody.innerHTML = "";

      rows.slice(0,4).forEach((r,idx)=>{
        const pct = calcPct(r.W, r.L, r.T);
        const streak = streakMap.get(r.team) || "—";
        const meta = getMeta(r.team);
        const href = teamHref(r.team);
        const style = meta.color ? `style="color:${meta.color}"` : "";

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="num">${idx+1}</td>
          <td>
            <div class="miniTeamCell">
              <img class="teamLogoMini" src="${meta.logo}" alt="${r.team} logo"
                   onerror="this.onerror=null; this.src='${window.DEFAULT_TEAM_LOGO || "./logo.png"}';">
              <a class="scheduleTeamLink" ${style} href="${href}">${r.team}</a>
            </div>
          </td>
          <td class="num">${r.W}</td>
          <td class="num">${r.L}</td>
          <td class="num">${r.T}</td>
          <td class="num">${fmtPct(pct)}</td>
          <td class="num">${streak}</td>
        `;
        miniBody.appendChild(tr);
      });

      document.getElementById("standingsMiniMsg").textContent =
        finalsCount ? `Based on ${finalsCount} final game(s).` : `No final games yet — standings will appear once games are marked Final.`;

      // Players of the Week (10 total, one per team)
      const potwGrid = document.getElementById("potwGrid");
      const potwMsg = document.getElementById("potwMsg");
      potwGrid.innerHTML = "";

      try{
        const potwCsv = await fetchCsv(window.SHEET?.PLAYERS_OF_WEEK_CSV_URL);
        const potw = parseCsv(potwCsv);

        const mapped = potw.map(r => {
          const team = safe(r.TeamName || r.Team);
          const playerID = safe(r.PlayerID);
          const name = safe(r.PlayerName || r.Name); // optional
          const photoOverride = safe(r.PhotoURL);
          const blurb = safe(r.Blurb || r.Why || r.Reason || r.Notes);
          const coach = safe(r.CoachName);
          const week = safe(r.Week);
          const weekDate = safe(r.WeekDate);

          const localPhoto = playerID ? `./player-photos/${encodeURIComponent(playerID)}.jpg` : "";
          const photo = photoOverride || localPhoto || (window.DEFAULT_PLAYER_PHOTO || "./logo.png");

          return {
            Team: team,
            TeamName: team,
            PlayerID: playerID,
            PlayerName: name || playerID || "Player",
            PhotoURL: photo,
            Blurb: blurb,
            CoachName: coach,
            Week: week,
            WeekDate: weekDate
          };
        }).filter(p => p.Team && p.PlayerID);

        // De-dupe: one per team
        const byTeam = new Map();
        for (const p of mapped){
          if (!byTeam.has(p.Team)) byTeam.set(p.Team, p);
        }
        const onePerTeam = Array.from(byTeam.values());

        // Sort newest first (WeekDate/Week), then Team name
        onePerTeam.sort((a,b)=>{
          const ad = parseDateLoose(a.WeekDate);
          const bd = parseDateLoose(b.WeekDate);
          if (ad && bd && bd.getTime() !== ad.getTime()) return bd - ad;
          const aw = Number(a.Week), bw = Number(b.Week);
          if (Number.isFinite(aw) && Number.isFinite(bw) && bw !== aw) return bw - aw;
          return a.Team.localeCompare(b.Team);
        });

        const show = onePerTeam.slice(0,10);

        show.forEach(p=>{
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "potwCardBtn";

          btn.innerHTML = `
            <img class="potwPhoto" src="${p.PhotoURL}" alt="${p.PlayerName}"
                 onerror="this.onerror=null; this.src='${window.DEFAULT_PLAYER_PHOTO || "./logo.png"}';">
            <div class="potwText">
              <div class="potwName">${p.PlayerName}</div>
              <div class="potwTeam muted small">${p.Team}</div>
              <div class="potwLink">Learn more →</div>
            </div>
          `;

          btn.addEventListener("click", ()=> renderPlayerModal(p));
          potwGrid.appendChild(btn);
        });

        potwMsg.textContent = show.length ? "" : "Players of the Week will appear here once the sheet is populated.";
      } catch(e){
        console.error(e);
        potwMsg.textContent = "Players of the Week unavailable right now (check tab publish + URL).";
      }
    }

    initHome().catch(err => console.error(err));
  </script>

  <script src="./nav.js"></script>
</body>
</html>
