<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl-home-v3" />
</head>

<body class="watermarkPage hasHamburger">
  <header class="siteHeader">
    <div class="navWrap">
      <button class="navToggle" type="button" aria-label="Open menu" aria-expanded="false" aria-controls="siteNav">
        <span></span><span></span><span></span>
      </button>

      <div class="navOverlay" aria-hidden="true"></div>

      <nav class="nav" id="siteNav">
        <a href="./" class="active">Home</a>
        <a href="./schedule.html">Schedule/Scores</a>
        <a href="./standings.html">Standings</a>
        <a href="./playoffs.html">Playoffs</a>
        <a href="./teams.html">Teams</a>
        <a href="./rules.html">Rules</a>
        <a href="./contacts.html">Contacts</a>
        <a href="./gallery.html">Gallery</a>
        <a href="./uploads.html">Uploads</a>
      </nav>
    </div>

    <div class="brandCenter">
      <img src="./logo.png" alt="WBL Logo" class="logoImage" />
      <h1>WBL 3rd Grade 2026</h1>
      <div class="tagline">Spring League Central</div>
    </div>
  </header>

  <main class="wrap">

    <!-- Welcome + Countdown -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeWelcome">
            <div class="muted" id="welcomeLine">
              Games Saturdays at <strong>10:00 AM</strong> and <strong>12:15 PM</strong> on fields <strong>T3, T4, T5</strong>.
            </div>

            <div class="homeCountdown" aria-live="polite" aria-atomic="true">
              <div class="homeCountdownLabel muted small" id="countdownLabel">Countdown to Opening Day (Apr 11)</div>
              <div class="homeCountdownTimer" id="countdownTimer">Loading…</div>
            </div>

            <div class="homeHeroBtns">
              <a class="btnPrimary" href="./schedule.html">This Week’s Games</a>
              <a class="btnSecondary" href="./standings.html">Standings</a>
              <a class="btnSecondary" href="./uploads.html">Upload Photos/Videos</a>
            </div>

            <div id="homeBannerNote" class="muted small" style="margin-top:12px; display:none;"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- This week + last week -->
    <section class="docSection">
      <div class="homeTwoCol">
        <div class="card">
          <div class="cardBody">
            <div class="homeSectionHead">
              <h3 style="margin:0;" id="thisWeekTitle">This Week</h3>
              <a class="linkPill" href="./schedule.html">Full Schedule →</a>
            </div>
            <div id="thisWeekGames" class="muted small">Loading…</div>
          </div>
        </div>

        <div class="card">
          <div class="cardBody">
            <div class="homeSectionHead">
              <h3 style="margin:0;" id="lastWeekTitle">Last Week (Finals)</h3>
              <a class="linkPill" href="./schedule.html">Scores →</a>
            </div>
            <div id="lastWeekFinals" class="muted small">Loading…</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Standings snapshot -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeSectionHead">
            <h3 style="margin:0;">Standings Snapshot (Top 4)</h3>
            <a class="linkPill" href="./standings.html">View Full Standings →</a>
          </div>

          <div class="tableScroll" style="margin-top:10px;">
            <table class="standingsTable" id="standingsMini">
              <thead>
                <tr>
                  <th class="num">#</th>
                  <th>Team</th>
                  <th class="num">W</th>
                  <th class="num">L</th>
                  <th class="num">T</th>
                  <th class="num">Win%</th>
                  <th class="num">Streak</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <p id="standingsMiniMsg" class="muted small" style="margin-top:10px;"></p>
        </div>
      </div>
    </section>

    <!-- Players of the Week -->
    <section class="docSection">
      <div class="card">
        <div class="cardBody">
          <div class="homeSectionHead">
            <div>
              <h3 style="margin:0;">Players of the Week</h3>
              <div class="muted small">One player per team — updated weekly.</div>
            </div>
          </div>

          <div id="potwGrid" class="potwGrid homePotwGrid" style="margin-top:12px;"></div>
          <p id="potwMsg" class="muted small" style="margin-top:10px;"></p>
        </div>
      </div>
    </section>

  </main>

  <!-- Modal -->
  <div id="modalOverlay" class="modalOverlay" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <button class="modalClose" id="modalCloseBtn" type="button">✕</button>
      <div id="modalContent"></div>
    </div>
  </div>

  <script src="./data.js"></script>
  <script>
    function safe(v){ return String(v ?? "").trim(); }
    function isFinal(status){ return safe(status).toLowerCase() === "final"; }

    function parseDateLoose(s){
      s = safe(s);
      if (!s) return null;

      const d1 = new Date(s);
      if (!isNaN(d1.getTime())) return d1;

      const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (m){
        const mm = Number(m[1]) - 1, dd = Number(m[2]), yy = Number(m[3]);
        const d2 = new Date(yy, mm, dd);
        return isNaN(d2.getTime()) ? null : d2;
      }
      return null;
    }

    async function fetchCsv(url){
      if (!url) throw new Error("Missing CSV URL in data.js");
      const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
      const res = await fetch(url + bust, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
      return await res.text();
    }

    function parseCsv(text){
      const rows = [];
      let row = [], cur = "", inQuotes = false;

      for (let i=0;i<text.length;i++){
        const ch = text[i], next = text[i+1];
        if (ch === '"'){
          if (inQuotes && next === '"'){ cur += '"'; i++; }
          else inQuotes = !inQuotes;
          continue;
        }
        if (!inQuotes && ch === ","){ row.push(cur); cur=""; continue; }
        if (!inQuotes && (ch === "\n" || ch === "\r")){
          if (ch === "\r" && next === "\n") i++;
          row.push(cur); cur="";
          if (row.some(v => safe(v)!=="")) rows.push(row);
          row=[]; continue;
        }
        cur += ch;
      }
      row.push(cur);
      if (row.some(v => safe(v)!=="")) rows.push(row);

      const headers = (rows.shift()||[]).map(h => safe(h).replace(/\s+/g,""));
      return rows.map(r => {
        const o = {};
        headers.forEach((h,idx)=> o[h]=safe(r[idx]));
        return o;
      });
    }

    // Modal
    const overlay = document.getElementById("modalOverlay");
    const modalContent = document.getElementById("modalContent");
    const closeBtn = document.getElementById("modalCloseBtn");

    function openModal(html){
      modalContent.innerHTML = html;
      overlay.classList.add("open");
      document.body.classList.add("noScroll");
      overlay.setAttribute("aria-hidden","false");
    }
    function closeModal(){
      overlay.classList.remove("open");
      document.body.classList.remove("noScroll");
      overlay.setAttribute("aria-hidden","true");
      modalContent.innerHTML = "";
    }
    closeBtn.addEventListener("click", closeModal);
    overlay.addEventListener("click", (e)=>{ if (e.target === overlay) closeModal(); });
    document.addEventListener("keydown",(e)=>{ if (e.key === "Escape") closeModal(); });

    function renderPlayerModal(player){
      const name = safe(player.PlayerName || player.Name || "Player");
      const team = safe(player.Team || player.TeamName || "");
      const photo = safe(player.PhotoURL) || (window.DEFAULT_PLAYER_PHOTO || "./logo.png");
      const blurb = safe(player.Blurb || player.Why || player.Reason || player.Notes || "");
      const coach = safe(player.CoachName);

      openModal(`
        <div class="profileHeader">
          <div class="profilePhoto">
            <img src="${photo}" alt="${name}" onerror="this.onerror=null; this.src='${window.DEFAULT_PLAYER_PHOTO || "./logo.png"}';">
          </div>
          <div>
            <h3 id="modalTitle" class="profileName">${name}</h3>
            ${team ? `<div class="muted" style="margin-top:4px;">${team}</div>` : ""}
            ${(blurb || coach) ? `
              <div class="card" style="margin-top:12px;">
                <div class="cardBody">
                  <div class="muted small">Coach’s Note${coach ? ` • ${coach}` : ""}</div>
                  <div style="margin-top:6px;">${blurb || "Write-up coming soon."}</div>
                </div>
              </div>
            ` : ""}
          </div>
        </div>
      `);
    }

    // ---- Opening Day + weekly anchor logic ----
    const LEAGUE_START_DATE = new Date(2026, 3, 11); // Apr 11, 2026 (month 0-indexed)
    const LEAGUE_START_GAME_TIME = "10:00 AM";

    function openingCountdownTarget(){
      const d = new Date(LEAGUE_START_DATE.getFullYear(), LEAGUE_START_DATE.getMonth(), LEAGUE_START_DATE.getDate());
      const dt = new Date(`${d.toDateString()} ${LEAGUE_START_GAME_TIME}`);
      return isNaN(dt.getTime()) ? d : dt;
    }

    function saturdayFor(date){
      const d = new Date(date);
      const day = d.getDay(); // 0 Sun ... 6 Sat
      const daysUntilSat = (6 - day + 7) % 7;
      const sat = new Date(d.getFullYear(), d.getMonth(), d.getDate() + daysUntilSat);
      sat.setHours(0,0,0,0);
      return sat;
    }

    function getDisplaySaturday(now){
      const openingSat = new Date(LEAGUE_START_DATE.getFullYear(), LEAGUE_START_DATE.getMonth(), LEAGUE_START_DATE.getDate());
      openingSat.setHours(0,0,0,0);

      // Before opening day: always show opening day games (Apr 11)
      if (now.getTime() < openingSat.getTime()) return openingSat;

      // After opening: show the next Saturday (including today if Saturday)
      return saturdayFor(now);
    }

    function fmtCountdown(ms){
      const total = Math.max(0, ms);
      const sec = Math.floor(total / 1000);
      const days = Math.floor(sec / 86400);
      const hrs = Math.floor((sec % 86400) / 3600);
      const mins = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const pad = (n)=> String(n).padStart(2,"0");
      return `${days}d ${pad(hrs)}h ${pad(mins)}m ${pad(s)}s`;
    }

    function updateCountdown(){
      const labelEl = document.getElementById("countdownLabel");
      const timerEl = document.getElementById("countdownTimer");
      if (!labelEl || !timerEl) return;

      const now = new Date();
      const openingTarget = openingCountdownTarget();

      // Before opening: countdown to Apr 11 @ 10:00 AM
      if (now.getTime() < openingTarget.getTime()){
        labelEl.textContent = "Countdown to Opening Day (Apr 11)";
        timerEl.textContent = fmtCountdown(openingTarget.getTime() - now.getTime());
        return;
      }

      // After opening: countdown to next Saturday's first game time (10:00 AM)
      const nextSat = getDisplaySaturday(now);
      const nextGame = new Date(`${nextSat.toDateString()} ${LEAGUE_START_GAME_TIME}`);
      labelEl.textContent = "Countdown to Next Game Day";
      timerEl.textContent = fmtCountdown(nextGame.getTime() - now.getTime());
    }

    // ---- Team meta (from Teams CSV headers you provided) ----
    function getTeamMetaMap(teamsRows){
      const m = new Map();
      (teamsRows || []).forEach(t => {
        const name = safe(t.TeamName);
        if (!name) return;

        const color = safe(t.TeamColor);
        const logo = safe(t.TeamLogo);

        m.set(name, {
          name,
          color,
          logo: logo || (window.DEFAULT_TEAM_LOGO || "./logo.png"),
          slug: safe(t.TeamSlug),
          id: safe(t.TeamID)
        });
      });
      return m;
    }

    function teamNameHtml(teamName, teamMap){
      const meta = teamMap?.get(teamName);
      const colorStyle = meta?.color ? `style="color:${meta.color};"` : "";
      return `<span class="teamNameColored" ${colorStyle}>${teamName}</span>`;
    }

    function teamLogoHtml(teamName, teamMap){
      const meta = teamMap?.get(teamName);
      const src = meta?.logo || (window.DEFAULT_TEAM_LOGO || "./logo.png");
      return `<img class="teamLogoMini" src="${src}" alt="${teamName} logo"
              onerror="this.onerror=null; this.src='${window.DEFAULT_TEAM_LOGO || "./logo.png"}';">`;
    }

    // ---- Schedule-like mini card renderer (home snapshot) ----
    function fmtGameRow(g, teamMap){
      const date = safe(g.Date);
      const time = safe(g.Time);
      const field = safe(g.Field);
      const a = safe(g.TeamA);
      const b = safe(g.TeamB);
      const sa = safe(g.ScoreA);
      const sb = safe(g.ScoreB);
      const status = safe(g.Status);

      const isF = isFinal(status);
      const score = isF ? `<div class="miniScore"><strong>${sa}-${sb}</strong></div>` : `<div class="miniScore muted small">—</div>`;
      const statusTxt = isF ? `<span class="pillFinal">Final</span>` : `<span class="muted small">Scheduled</span>`;

      return `
        <div class="miniGameCard">
          <div class="miniGameMeta muted small">
            ${date}${time ? " • " + time : ""}${field ? " • " + field : ""}
          </div>

          <div class="miniGameBody">
            <div class="miniTeams">
              <div class="miniTeamRow">
                ${teamLogoHtml(a, teamMap)}
                <div class="miniTeamName">${teamNameHtml(a, teamMap)}</div>
              </div>

              <div class="miniTeamRow">
                ${teamLogoHtml(b, teamMap)}
                <div class="miniTeamName">${teamNameHtml(b, teamMap)}</div>
              </div>
            </div>

            <div class="miniRight">
              ${score}
              <div class="miniStatus">${statusTxt}</div>
            </div>
          </div>
        </div>
      `;
    }

    // ---- Standings calculations ----
    function toNum(x){
      const n = Number(safe(x));
      return Number.isFinite(n) ? n : null;
    }

    function calcPct(W,L,T){
      const gp = W + L + T;
      if (!gp) return 0;
      return (W + 0.5*T) / gp;
    }

    function fmtPct(p){
      return (p * 100).toFixed(1);
    }

    function buildStreaksFromFinals(games){
      const byTeam = new Map();

      function pushResult(team, res){
        if (!team) return;
        if (!byTeam.has(team)) byTeam.set(team, []);
        byTeam.get(team).push(res);
      }

      const finals = games
        .filter(g => isFinal(g.Status))
        .map(g => ({ g, d: parseDateLoose(g.Date) }))
        .filter(x => x.d)
        .sort((a,b)=> a.d - b.d)
        .map(x => x.g);

      for (const g of finals){
        const a = safe(g.TeamA), b = safe(g.TeamB);
        const sa = toNum(g.ScoreA), sb = toNum(g.ScoreB);
        if (!a || !b || sa===null || sb===null) continue;

        if (sa > sb){ pushResult(a,"W"); pushResult(b,"L"); }
        else if (sb > sa){ pushResult(b,"W"); pushResult(a,"L"); }
        else { pushResult(a,"T"); pushResult(b,"T"); }
      }

      const streak = new Map();
      for (const [team, arr] of byTeam.entries()){
        if (!arr.length){ streak.set(team,"—"); continue; }
        const last = arr[arr.length-1];
        let n = 1;
        for (let i=arr.length-2; i>=0; i--){
          if (arr[i] === last) n++;
          else break;
        }
        streak.set(team, `${last}${n}`);
      }
      return streak;
    }

    async function initHome(){
      // Countdown timer
      updateCountdown();
      setInterval(updateCountdown, 1000);

      // Teams feed (logos + colors)
      let teamMap = new Map();
      try{
        const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
        const teams = parseCsv(teamsCsv);
        teamMap = getTeamMetaMap(teams);
      } catch(e){
        console.warn("Teams feed unavailable for home styling.", e);
      }

      // Games feed
      const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
      const games = parseCsv(gamesCsv);

      // Determine which Saturday we're showing
      const now = new Date();
      const thisSat = getDisplaySaturday(now);
      const lastSat = new Date(thisSat.getFullYear(), thisSat.getMonth(), thisSat.getDate() - 7);
      lastSat.setHours(0,0,0,0);

      const thisWeekTitle = document.getElementById("thisWeekTitle");
      const bannerNote = document.getElementById("homeBannerNote");

      const openingSat = new Date(LEAGUE_START_DATE.getFullYear(), LEAGUE_START_DATE.getMonth(), LEAGUE_START_DATE.getDate());
      openingSat.setHours(0,0,0,0);

      const fmtShort = (d)=> d.toLocaleDateString(undefined, { month:"short", day:"numeric" });

      if (now.getTime() < openingSat.getTime()){
        thisWeekTitle.textContent = `Opening Day (${fmtShort(thisSat)})`;
        bannerNote.textContent = `Showing Opening Day games on ${fmtShort(thisSat)}.`;
        bannerNote.style.display = "";
      } else {
        thisWeekTitle.textContent = `This Week (${fmtShort(thisSat)})`;
        bannerNote.style.display = "none";
      }

      // Partition games by date = thisSat / lastSat
      const thisWeek = [];
      const lastWeekFinals = [];

      for (const g of games){
        const d = parseDateLoose(g.Date);
        if (!d) continue;
        d.setHours(0,0,0,0);

        if (d.getTime() === thisSat.getTime()){
          thisWeek.push(g);
        }
        if (d.getTime() === lastSat.getTime() && isFinal(g.Status)){
          lastWeekFinals.push(g);
        }
      }

      const thisEl = document.getElementById("thisWeekGames");
      thisEl.innerHTML = thisWeek.length
        ? thisWeek.map(g => fmtGameRow(g, teamMap)).join("")
        : `<div class="muted small">No games found for ${fmtShort(thisSat)} yet.</div>`;

      const lastEl = document.getElementById("lastWeekFinals");
      lastEl.innerHTML = lastWeekFinals.length
        ? lastWeekFinals.map(g => fmtGameRow(g, teamMap)).join("")
        : `<div class="muted small">No final games from ${fmtShort(lastSat)} yet.</div>`;

      // Standings snapshot from Final games
      const teamsSet = new Set();
      games.forEach(g => {
        if (safe(g.TeamA)) teamsSet.add(safe(g.TeamA));
        if (safe(g.TeamB)) teamsSet.add(safe(g.TeamB));
      });

      const table = new Map();
      for (const t of teamsSet) table.set(t, { team:t, W:0, L:0, T:0 });

      let finalsCount = 0;
      for (const g of games){
        if (!isFinal(g.Status)) continue;
        const a = safe(g.TeamA), b = safe(g.TeamB);
        const sa = toNum(g.ScoreA), sb = toNum(g.ScoreB);
        if (!a || !b || sa===null || sb===null) continue;

        if (!table.has(a)) table.set(a,{team:a,W:0,L:0,T:0});
        if (!table.has(b)) table.set(b,{team:b,W:0,L:0,T:0});

        if (sa > sb){ table.get(a).W++; table.get(b).L++; }
        else if (sb > sa){ table.get(b).W++; table.get(a).L++; }
        else { table.get(a).T++; table.get(b).T++; }

        finalsCount++;
      }

      const rows = Array.from(table.values()).sort((x,y)=>{
        // Use win% first, then W, then L, then team name (more standings-like)
        const xp = calcPct(x.W,x.L,x.T);
        const yp = calcPct(y.W,y.L,y.T);
        if (yp !== xp) return yp - xp;
        if (y.W !== x.W) return y.W - x.W;
        if (x.L !== y.L) return x.L - y.L;
        return x.team.localeCompare(y.team);
      });

      const streakMap = buildStreaksFromFinals(games);

      const miniBody = document.querySelector("#standingsMini tbody");
      miniBody.innerHTML = "";

      rows.slice(0,4).forEach((r,idx)=>{
        const pct = calcPct(r.W, r.L, r.T);
        const streak = streakMap.get(r.team) || "—";

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="num">${idx+1}</td>
          <td>
            <div class="miniTeamCell">
              ${teamLogoHtml(r.team, teamMap)}
              <div class="miniTeamCellName">${teamNameHtml(r.team, teamMap)}</div>
            </div>
          </td>
          <td class="num">${r.W}</td>
          <td class="num">${r.L}</td>
          <td class="num">${r.T}</td>
          <td class="num">${fmtPct(pct)}</td>
          <td class="num">${streak}</td>
        `;
        miniBody.appendChild(tr);
      });

      document.getElementById("standingsMiniMsg").textContent =
        finalsCount ? `Based on ${finalsCount} final game(s).` : `No final games yet — standings will appear once games are marked Final.`;

      // Players of the Week (10 total, one per team)
      const potwGrid = document.getElementById("potwGrid");
      const potwMsg = document.getElementById("potwMsg");
      potwGrid.innerHTML = "";

      try{
        const potwCsv = await fetchCsv(window.SHEET?.PLAYERS_OF_WEEK_CSV_URL);
        const potw = parseCsv(potwCsv);

        const mapped = potw.map(r => {
          const team = safe(r.TeamName || r.Team);
          const playerID = safe(r.PlayerID);
          const name = safe(r.PlayerName || r.Name); // optional if present
          const photoOverride = safe(r.PhotoURL);
          const blurb = safe(r.Blurb || r.Why || r.Reason || r.Notes);
          const coach = safe(r.CoachName);
          const week = safe(r.Week);
          const weekDate = safe(r.WeekDate);

          const localPhoto = playerID ? `./player-photos/${encodeURIComponent(playerID)}.jpg` : "";
          const photo = photoOverride || localPhoto || (window.DEFAULT_PLAYER_PHOTO || "./logo.png");

          return {
            Team: team,
            TeamName: team,
            PlayerID: playerID,
            PlayerName: name || playerID || "Player",
            PhotoURL: photo,
            Blurb: blurb,
            CoachName: coach,
            Week: week,
            WeekDate: weekDate
          };
        }).filter(p => p.Team && p.PlayerID);

        // De-dupe: one per team
        const byTeam = new Map();
        for (const p of mapped){
          if (!byTeam.has(p.Team)) byTeam.set(p.Team, p);
        }
        const onePerTeam = Array.from(byTeam.values());

        // Sort newest first (WeekDate/Week), then Team name
        onePerTeam.sort((a,b)=>{
          const ad = parseDateLoose(a.WeekDate);
          const bd = parseDateLoose(b.WeekDate);
          if (ad && bd && bd.getTime() !== ad.getTime()) return bd - ad;
          const aw = Number(a.Week), bw = Number(b.Week);
          if (Number.isFinite(aw) && Number.isFinite(bw) && bw !== aw) return bw - aw;
          return a.Team.localeCompare(b.Team);
        });

        const show = onePerTeam.slice(0,10);

        show.forEach(p=>{
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "potwCardBtn";

          btn.innerHTML = `
            <img class="potwPhoto" src="${p.PhotoURL}" alt="${p.PlayerName}"
                 onerror="this.onerror=null; this.src='${window.DEFAULT_PLAYER_PHOTO || "./logo.png"}';">
            <div class="potwText">
              <div class="potwName">${p.PlayerName}</div>
              <div class="potwTeam muted small">${p.Team}</div>
              <div class="potwLink">Learn more →</div>
            </div>
          `;

          btn.addEventListener("click", ()=> renderPlayerModal(p));
          potwGrid.appendChild(btn);
        });

        potwMsg.textContent = show.length ? "" : "Players of the Week will appear here once the sheet is populated.";
      } catch(e){
        console.error(e);
        potwMsg.textContent = "Players of the Week unavailable right now (check tab publish + URL).";
      }
    }

    initHome().catch(err => console.error(err));
  </script>

  <script src="./nav.js"></script>
</body>
</html>
