<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Playoffs • WBL 3rd Grade 2026</title>
  <link rel="stylesheet" href="./styles.css?v=wbl2026" />
</head>

<body class="watermarkPage playoffsPage hasHamburger">
<header class="siteHeader">
  <div class="navWrap">
    <button
      class="navToggle"
      type="button"
      aria-label="Open menu"
      aria-expanded="false"
      aria-controls="siteNav"
    >
      <span></span><span></span><span></span>
    </button>

    <div class="navOverlay" aria-hidden="true"></div>

    <nav class="nav" id="siteNav">
      <a href="./">Home</a>
      <a href="./schedule.html">Schedule/Scores</a>
      <a href="./standings.html">Standings</a>
      <a href="./playoffs.html" class="active">Playoffs</a>
      <a href="./teams.html">Teams</a>
      <a href="./rules.html">Rules</a>
      <a href="./contacts.html">Contacts</a>
      <a href="./gallery.html">Gallery</a>
      <a href="./uploads.html">Uploads</a>
    </nav>
  </div>

  <div class="brandCenter">
    <img src="./logo.png" alt="WBL Logo" class="logoImage" />
    <h1>WBL 3rd Grade 2026</h1>
    <div class="tagline">Playoffs</div>
  </div>
</header>

<main class="wrap">
  <section class="docSection">

    <div class="standingsHeaderCard">
      <div class="standingsHeaderTitle">Playoffs</div>
      <div class="standingsHeaderSub muted">
        Brackets auto-fill from regular season standings and playoff results.
      </div>
      <div class="standingsHeaderMeta muted small" id="playoffsUpdated"></div>
      <div class="muted small" id="seedNote" style="margin-top:6px;"></div>
    </div>

    <!-- Championship Bracket -->
    <div class="card" style="margin-top:14px;">
      <div class="cardBody">
        <h2 style="margin:0 0 8px 0;">Championship Bracket (Seeds 1–6)</h2>
        <div id="championshipWrap"></div>
      </div>
    </div>

    <!-- Consolation Bracket -->
    <div class="card" style="margin-top:14px;">
      <div class="cardBody">
        <h2 style="margin:0 0 8px 0;">Consolation Bracket (Seeds 7–10)</h2>
        <div id="consolationWrap"></div>
      </div>
    </div>

    <p id="playoffsMsg" class="muted small" style="margin-top:12px;"></p>
  </section>
</main>

<script src="./data.js"></script>

<script>
  const updatedEl = document.getElementById("playoffsUpdated");
  const seedNoteEl = document.getElementById("seedNote");
  const msgEl = document.getElementById("playoffsMsg");

  const champWrap = document.getElementById("championshipWrap");
  const consWrap  = document.getElementById("consolationWrap");

  function safe(v){ return String(v ?? "").trim(); }
  function normalizeKey(s){ return safe(s).toLowerCase(); }

  function isFinal(status){
    const s = safe(status).toLowerCase();
    return s === "final" || s.startsWith("final");
  }

  function toNum(x){
    const n = Number(safe(x));
    return Number.isFinite(n) ? n : null;
  }

  async function fetchCsv(url) {
    if (!url) throw new Error("Missing CSV URL in data.js");
    const bust = (url.includes("?") ? "&" : "?") + "t=" + Date.now();
    const res = await fetch(url + bust, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch CSV (${res.status})`);
    return await res.text();
  }

  // Robust CSV parser (quoted commas safe) + BOM strip
  function parseCsv(text) {
    const rows = [];
    let row = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      const next = text[i + 1];

      if (ch === '"') {
        if (inQuotes && next === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
        continue;
      }

      if (!inQuotes && ch === ",") { row.push(cur); cur = ""; continue; }

      if (!inQuotes && (ch === "\n" || ch === "\r")) {
        if (ch === "\r" && next === "\n") i++;
        row.push(cur); cur = "";
        if (row.some(v => safe(v) !== "")) rows.push(row);
        row = [];
        continue;
      }

      cur += ch;
    }

    row.push(cur);
    if (row.some(v => safe(v) !== "")) rows.push(row);

    const headers = (rows.shift() || []).map((h) => {
      let key = safe(h).replace(/\s+/g, "");
      key = key.replace(/^\uFEFF/, "");
      return key;
    });

    return rows
      .filter(r => r.some(x => safe(x) !== ""))
      .map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h] = safe(r[idx]));
        return obj;
      });
  }

  // --- Standings (Seeds) from regular season Games tab ---
  function buildStandings(teamNames){
    const map = new Map();
    for (const name of teamNames) {
      if (!name) continue;
      map.set(name, { team: name, W: 0, L: 0, T: 0, RF: 0, RA: 0, RD: 0 });
    }
    return map;
  }

  function sortStandings(a, b) {
    // W desc, L asc, RD desc, RF desc, name asc
    if (b.W !== a.W) return b.W - a.W;
    if (a.L !== b.L) return a.L - b.L;
    if (b.RD !== a.RD) return b.RD - a.RD;
    if (b.RF !== a.RF) return b.RF - a.RF;
    return a.team.localeCompare(b.team);
  }

  function computeSeedsFromGames(teamNames, gameRows){
    const standings = buildStandings(teamNames);

    const finals = gameRows.filter(g => isFinal(g.Status));
    for (const g of finals) {
      const aName = safe(g.TeamA);
      const bName = safe(g.TeamB);
      const scoreA = toNum(g.ScoreA);
      const scoreB = toNum(g.ScoreB);
      if (!aName || !bName || scoreA === null || scoreB === null) continue;

      if (!standings.has(aName)) standings.set(aName, { team: aName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });
      if (!standings.has(bName)) standings.set(bName, { team: bName, W:0, L:0, T:0, RF:0, RA:0, RD:0 });

      const A = standings.get(aName);
      const B = standings.get(bName);

      A.RF += scoreA; A.RA += scoreB;
      B.RF += scoreB; B.RA += scoreA;

      if (scoreA > scoreB) { A.W++; B.L++; }
      else if (scoreB > scoreA) { B.W++; A.L++; }
      else { A.T++; B.T++; }
    }

    for (const v of standings.values()) v.RD = v.RF - v.RA;

    const ordered = Array.from(standings.values()).sort(sortStandings);
    const bySeed = new Map();
    ordered.forEach((row, idx) => bySeed.set(idx + 1, row.team));
    return { ordered, bySeed };
  }

  // --- Resolve S#/W###/L### into TeamName ---
  function winnerLoserFromPlayoffGame(gameRow){
    if (!isFinal(gameRow.Status)) return null;
    const a = toNum(gameRow.ScoreA);
    const b = toNum(gameRow.ScoreB);
    if (a === null || b === null) return null;

    const A = safe(gameRow.TeamAResolved);
    const B = safe(gameRow.TeamBResolved);
    if (!A || !B) return null;

    if (a === b) return { T: true, A, B };
    return a > b ? { W: A, L: B } : { W: B, L: A };
  }

  function resolveTeamRef(ref, seedsByNum, playoffsById, teamNameToSlug){
    const raw = safe(ref);
    if (!raw) return null;

    // If it matches a real TeamName, accept it directly
    if (teamNameToSlug.has(normalizeKey(raw))) return raw;

    const up = raw.toUpperCase();

    // Seed ref like S3
    if (/^S\d+$/.test(up)) {
      const n = Number(up.slice(1));
      return seedsByNum.get(n) || null;
    }

    // Winner/Loser ref like W146 / L147
    if (/^[WL]\d+$/.test(up)) {
      const type = up[0]; // W or L
      const gid = Number(up.slice(1));
      const g = playoffsById.get(gid);
      if (!g) return null;

      // Ensure referenced game's teams are resolved first
      const wl = winnerLoserFromPlayoffGame(g);
      if (!wl || wl.T) return null;

      return (type === "W") ? wl.W : wl.L;
    }

    // Unknown token -> treat as TBD
    return null;
  }

  function teamLink(teamName, teamNameToSlug){
    const name = safe(teamName) || "TBD";
    const slug = teamNameToSlug.get(normalizeKey(name));
    if (!slug) return `<span>${name}</span>`;
    return `<a class="teamLinkInline" href="./team.html?team=${encodeURIComponent(slug)}">${name}</a>`;
  }

  function gameCardHTML(g, teamNameToSlug){
    const id = safe(g.GameID);
    const date = safe(g.Date);
    const time = safe(g.Time);
    const field = safe(g.Field);
    const status = safe(g.Status) || "Scheduled";

    const a = g.TeamAResolved || "TBD";
    const b = g.TeamBResolved || "TBD";

    const final = isFinal(status);
    const sA = toNum(g.ScoreA);
    const sB = toNum(g.ScoreB);
    const score = (final && sA !== null && sB !== null) ? `${sA}-${sB}` : "";

    const metaParts = [];
    if (date) metaParts.push(date);
    if (time) metaParts.push(time);
    if (field) metaParts.push(field);
    const meta = metaParts.join(" • ");

    return `
      <div class="card" style="margin-top:10px;">
        <div class="cardBody">
          <div style="display:flex; justify-content:space-between; gap:10px; align-items:flex-start;">
            <div>
              <div class="muted small">${id ? `Game ${id}` : ""}</div>
              <div style="font-weight:900; margin-top:2px;">
                ${teamLink(a, teamNameToSlug)}
                <span class="vsSep">vs</span>
                ${teamLink(b, teamNameToSlug)}
              </div>
              <div class="muted small" style="margin-top:4px;">${meta}</div>
            </div>
            <div style="text-align:right;">
              <div class="muted small">${final ? "Final" : status}</div>
              <div style="font-weight:900; font-size:18px; margin-top:2px;">${score}</div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  function renderRoundSection(title, gameIds, playoffsById, wrap, teamNameToSlug){
    const games = gameIds
      .map(id => playoffsById.get(id))
      .filter(Boolean);

    if (!games.length) return;

    let html = `<h3 style="margin:14px 0 6px 0;">${title}</h3>`;
    for (const g of games) html += gameCardHTML(g, teamNameToSlug);

    wrap.insertAdjacentHTML("beforeend", html);
  }

  function classifyPlayoffGameIds(allGameIds){
    // Default to your design:
    // Championship: 146–150
    // Consolation: 151–155
    const champ = [];
    const cons = [];

    for (const id of allGameIds) {
      if (id >= 146 && id <= 150) champ.push(id);
      else if (id >= 151 && id <= 155) cons.push(id);
      else {
        // If you ever change IDs later, keep extras in consolation by default
        cons.push(id);
      }
    }

    return { champ, cons };
  }

  async function init(){
    msgEl.textContent = "";
    updatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;

    // Load Teams (for list + name->slug mapping)
    const teamsCsv = await fetchCsv(window.SHEET?.TEAMS_CSV_URL);
    const teamRows = parseCsv(teamsCsv);

    const teamNames = teamRows.map(r => safe(r.TeamName)).filter(Boolean);

    const teamNameToSlug = new Map();
    for (const r of teamRows) {
      const name = safe(r.TeamName);
      const slug = safe(r.TeamSlug);
      if (name && slug) teamNameToSlug.set(normalizeKey(name), slug);
    }

    // Load regular season games (to compute seeds)
    const gamesCsv = await fetchCsv(window.SHEET?.GAMES_CSV_URL);
    const gameRows = parseCsv(gamesCsv);

    const { ordered, bySeed } = computeSeedsFromGames(teamNames, gameRows);

    // Seed note (top 10 preview)
    const seedPreview = ordered.slice(0, 10).map((r, i) => `S${i+1}: ${r.team}`).join(" • ");
    seedNoteEl.textContent = seedPreview ? `Current seeding: ${seedPreview}` : "";

    // Load playoffs games
    const playoffsCsv = await fetchCsv(window.SHEET?.PLAYOFFS_CSV_URL);
    const playoffRows = parseCsv(playoffsCsv);

    // Build map by numeric GameID
    const playoffsById = new Map();
    for (const r of playoffRows) {
      const id = Number(safe(r.GameID));
      if (!Number.isFinite(id)) continue;
      playoffsById.set(id, r);
    }

    const allIds = Array.from(playoffsById.keys()).sort((a,b) => a - b);
    if (!allIds.length) {
      msgEl.textContent = "No playoff games found. Check your Playoffs tab is published and has GameID rows.";
      return;
    }

    // First pass: resolve TeamA/TeamB for every playoff row (seed refs / names)
    // Second pass handles W/L refs after referenced games can be resolved.
    for (let pass = 0; pass < 3; pass++) {
      for (const id of allIds) {
        const g = playoffsById.get(id);
        const aRef = safe(g.TeamA);
        const bRef = safe(g.TeamB);

        const aResolved = resolveTeamRef(aRef, bySeed, playoffsById, teamNameToSlug);
        const bResolved = resolveTeamRef(bRef, bySeed, playoffsById, teamNameToSlug);

        g.TeamAResolved = aResolved;
        g.TeamBResolved = bResolved;
      }
    }

    const { champ, cons } = classifyPlayoffGameIds(allIds);

    // Render Championship (your 5-game format)
    champWrap.innerHTML = "";
    renderRoundSection("Round 1", [146, 147], playoffsById, champWrap, teamNameToSlug);
    renderRoundSection("Semifinals", [148, 149], playoffsById, champWrap, teamNameToSlug);
    renderRoundSection("Championship", [150], playoffsById, champWrap, teamNameToSlug);

    // Render Consolation (your 5-game format)
    consWrap.innerHTML = "";
    renderRoundSection("Round 1", [151, 152], playoffsById, consWrap, teamNameToSlug);
    renderRoundSection("Round 2", [153, 154, 155], playoffsById, consWrap, teamNameToSlug);

    // If you ever change GameIDs, still show anything that wasn’t included above:
    const rendered = new Set([146,147,148,149,150,151,152,153,154,155]);
    const extrasChamp = champ.filter(id => !rendered.has(id));
    const extrasCons  = cons.filter(id => !rendered.has(id));

    if (extrasChamp.length) renderRoundSection("Additional Games", extrasChamp, playoffsById, champWrap, teamNameToSlug);
    if (extrasCons.length)  renderRoundSection("Additional Games", extrasCons, playoffsById, consWrap, teamNameToSlug);

    msgEl.textContent = "Brackets will auto-fill as games are marked Final and scores are entered.";
  }

  init().catch(err => {
    console.error(err);
    msgEl.textContent = "Playoffs error: " + err.message;
  });
</script>

<script src="./nav.js"></script>
</body>
</html>
